// Relations
export const usersRelations = relations(users, ({ many }) => ({
  encounters: many(encounters),
  appointments: many(appointments),
  signatures: many(signatures),
  labOrders: many(labOrders),
  imagingOrders: many(imagingOrders),
  orders: many(orders),
  orderedOrders: many(orders, { relationName: "orderedBy" }),
  approvedOrders: many(orders, { relationName: "approvedBy" }),
}));

// Replaced by patientsRelationsEnhanced below

export const encountersRelations = relations(encounters, ({ one, many }) => ({
  patient: one(patients, {
    fields: [encounters.patientId],
    references: [patients.id],
  }),
  provider: one(users, {
    fields: [encounters.providerId],
    references: [users.id],
  }),
  appointment: one(appointments, {
    fields: [encounters.appointmentId],
    references: [appointments.id],
  }),
  signatures: many(signatures),
  vitals: many(vitals),
  medications: many(medications),
  diagnoses: many(diagnoses),
  labOrders: many(labOrders),
  imagingOrders: many(imagingOrders),
  orders: many(orders),
  attachments: many(patientAttachments),
}));

// Replaced by appointmentsRelationsEnhanced below

export const signaturesRelations = relations(signatures, ({ one, many }) => ({
  signedByUser: one(users, {
    fields: [signatures.signedBy],
    references: [users.id],
  }),
  encounter: one(encounters, {
    fields: [signatures.encounterId],
    references: [encounters.id],
  }),
}));

export const labOrdersRelations = relations(labOrders, ({ one, many }) => ({
  patient: one(patients, {
    fields: [labOrders.patientId],
    references: [patients.id],
  }),
  encounter: one(encounters, {
    fields: [labOrders.encounterId],
    references: [encounters.id],
  }),
  orderedByUser: one(users, {
    fields: [labOrders.orderedBy],
    references: [users.id],
  }),
  results: many(labResults),
}));

export const labResultsRelations = relations(labResults, ({ one }) => ({
  labOrder: one(labOrders, {
    fields: [labResults.labOrderId],
    references: [labOrders.id],
  }),
  patient: one(patients, {
    fields: [labResults.patientId],
    references: [patients.id],
  }),
  reviewedByUser: one(users, {
    fields: [labResults.reviewedBy],
    references: [users.id],
  }),
}));

export const labReferenceRangesRelations = relations(labReferenceRanges, ({ many }) => ({
  // No direct relations - this is a lookup table queried by LOINC code
}));

export const imagingOrdersRelations = relations(imagingOrders, ({ one, many }) => ({
  patient: one(patients, {
    fields: [imagingOrders.patientId],
    references: [patients.id],
  }),
  encounter: one(encounters, {
    fields: [imagingOrders.encounterId],
    references: [encounters.id],
  }),
  orderedByUser: one(users, {
    fields: [imagingOrders.providerId],
    references: [users.id],
  }),
  results: many(imagingResults),
}));

export const imagingResultsRelations = relations(imagingResults, ({ one }) => ({
  imagingOrder: one(imagingOrders, {
    fields: [imagingResults.imagingOrderId],
    references: [imagingOrders.id],
  }),
  patient: one(patients, {
    fields: [imagingResults.patientId],
    references: [patients.id],
  }),
}));

export const patientPhysicalFindingsRelations = relations(patientPhysicalFindings, ({ one }) => ({
  patient: one(patients, {
    fields: [patientPhysicalFindings.patientId],
    references: [patients.id],
  }),
  firstNotedEncounter: one(encounters, {
    fields: [patientPhysicalFindings.firstNotedEncounter],
    references: [encounters.id],
  }),
  lastConfirmedEncounter: one(encounters, {
    fields: [patientPhysicalFindings.lastConfirmedEncounter],
    references: [encounters.id],
  }),
  lastSeenEncounter: one(encounters, {
    fields: [patientPhysicalFindings.lastSeenEncounter],
    references: [encounters.id],
  }),
}));

export const ordersRelations = relations(orders, ({ one }) => ({
  patient: one(patients, {
    fields: [orders.patientId],
    references: [patients.id],
  }),
  encounter: one(encounters, {
    fields: [orders.encounterId],
    references: [encounters.id],
  }),
  orderedByUser: one(users, {
    fields: [orders.orderedBy],
    references: [users.id],
  }),
  approvedByUser: one(users, {
    fields: [orders.approvedBy],
    references: [users.id],
  }),
}));

export const medicalProblemsRelations = relations(medicalProblems, ({ one }) => ({
  patient: one(patients, {
    fields: [medicalProblems.patientId],
    references: [patients.id],
  }),
  firstEncounter: one(encounters, {
    fields: [medicalProblems.firstEncounterId],
    references: [encounters.id],
  }),
  lastUpdatedEncounter: one(encounters, {
    fields: [medicalProblems.lastUpdatedEncounterId],
    references: [encounters.id],
  }),
}));

export const medicationsRelations = relations(medications, ({ one, many }) => ({
  patient: one(patients, {
    fields: [medications.patientId],
    references: [patients.id],
  }),
  encounter: one(encounters, {
    fields: [medications.encounterId],
    references: [encounters.id],
  }),
  prescriber: one(users, {
    fields: [medications.prescriberId],
    references: [users.id],
  }),
  firstEncounter: one(encounters, {
    fields: [medications.firstEncounterId],
    references: [encounters.id],
  }),
  lastUpdatedEncounter: one(encounters, {
    fields: [medications.lastUpdatedEncounterId],
    references: [encounters.id],
  }),
  extractedFromAttachment: one(patientAttachments, {
    fields: [medications.extractedFromAttachmentId],
    references: [patientAttachments.id],
  }),
  enteredByUser: one(users, {
    fields: [medications.enteredBy],
    references: [users.id],
  }),
  electronicSignature: one(electronicSignatures, {
    fields: [medications.electronicSignatureId],
    references: [electronicSignatures.id],
  }),
  transmissions: many(prescriptionTransmissions),
}));

export const electronicSignaturesRelations = relations(electronicSignatures, ({ one, many }) => ({
  user: one(users, {
    fields: [electronicSignatures.userId],
    references: [users.id],
  }),
  encounter: one(encounters, {
    fields: [electronicSignatures.encounterId],
    references: [encounters.id],
  }),
  medications: many(medications),
}));

export const pharmaciesRelations = relations(pharmacies, ({ many }) => ({
  prescriptionTransmissions: many(prescriptionTransmissions),
}));

export const prescriptionTransmissionsRelations = relations(prescriptionTransmissions, ({ one }) => ({
  medication: one(medications, {
    fields: [prescriptionTransmissions.medicationId],
    references: [medications.id],
  }),
  order: one(orders, {
    fields: [prescriptionTransmissions.orderId],
    references: [orders.id],
  }),
  patient: one(patients, {
    fields: [prescriptionTransmissions.patientId],
    references: [patients.id],
  }),
  provider: one(users, {
    fields: [prescriptionTransmissions.providerId],
    references: [users.id],
  }),
  pharmacy: one(pharmacies, {
    fields: [prescriptionTransmissions.pharmacyId],
    references: [pharmacies.id],
  }),
  electronicSignature: one(electronicSignatures, {
    fields: [prescriptionTransmissions.electronicSignatureId],
    references: [electronicSignatures.id],
  }),
}));

export const patientOrderPreferencesRelations = relations(patientOrderPreferences, ({ one }) => ({
  patient: one(patients, {
    fields: [patientOrderPreferences.patientId],
    references: [patients.id],
  }),
  lastUpdatedByUser: one(users, {
    fields: [patientOrderPreferences.lastUpdatedBy],
    references: [users.id],
  }),
}));

export const signedOrdersRelations = relations(signedOrders, ({ one }) => ({
  order: one(orders, {
    fields: [signedOrders.orderId],
    references: [orders.id],
  }),
  patient: one(patients, {
    fields: [signedOrders.patientId],
    references: [patients.id],
  }),
  encounter: one(encounters, {
    fields: [signedOrders.encounterId],
    references: [encounters.id],
  }),
  signedByUser: one(users, {
    fields: [signedOrders.signedBy],
    references: [users.id],
  }),
}));

// Medical Problems Types
export type MedicalProblem = typeof medicalProblems.$inferSelect;
export type InsertMedicalProblem = z.infer<typeof insertMedicalProblemSchema>;

// Medication Formulary Types
export type MedicationFormulary = typeof medicationFormulary.$inferSelect;
export type InsertMedicationFormulary = z.infer<typeof insertMedicationFormularySchema>;

// Insert schemas
export const insertUserSchema = createInsertSchema(users).pick({
  username: true,
  email: true,
  password: true,
  firstName: true,
  lastName: true,
  role: true,
  healthSystemId: true,
  npi: true,
  credentials: true,
  specialties: true,
  licenseNumber: true,
});

export const insertPatientSchema = createInsertSchema(patients).pick({
  mrn: true,
  healthSystemId: true,
  firstName: true,
  lastName: true,
  dateOfBirth: true,
  gender: true,
  contactNumber: true,
  email: true,
  address: true,
  emergencyContact: true,
  insurancePrimary: true,
  insuranceSecondary: true,
  policyNumber: true,
  groupNumber: true,
  preferredLocationId: true,
  dataOriginType: true,
  originalFacilityId: true,
  createdByProviderId: true,
  creationContext: true,
  derivativeWorkNote: true,
  migrationConsent: true,
}).extend({
  mrn: z.string().optional(), // Make MRN optional since we auto-generate it
});

export const insertEncounterSchema = createInsertSchema(encounters).pick({
  patientId: true,
  providerId: true,
  encounterType: true,
  encounterSubtype: true,
  encounterStatus: true,
  chiefComplaint: true,
  note: true,
  nurseAssessment: true,
  nurseInterventions: true,
  nurseNotes: true,
  location: true,
});



export const insertOrderSchema = createInsertSchema(orders).pick({
  patientId: true,
  encounterId: true,
  providerId: true,
  orderType: true,
  orderStatus: true,
  referenceId: true,
  providerNotes: true,
  priority: true,
  clinicalIndication: true,
  medicationName: true,
  dosage: true,
  quantity: true,
  sig: true,
  refills: true,
  form: true,
  routeOfAdministration: true,
  daysSupply: true,
  diagnosisCode: true,
  requiresPriorAuth: true,
  priorAuthNumber: true,
  labName: true,
  testName: true,
  testCode: true,
  specimenType: true,
  fastingRequired: true,
  studyType: true,
  region: true,
  laterality: true,
  contrastNeeded: true,
  specialtyType: true,
  providerName: true,
  urgency: true,
  orderedBy: true,
  approvedBy: true,
});

export const insertMedicalProblemSchema = createInsertSchema(medicalProblems).pick({
  patientId: true,
  problemTitle: true,
  currentIcd10Code: true,
  problemStatus: true,
  firstDiagnosedDate: true,
  firstEncounterId: true,
  lastUpdatedEncounterId: true,
  visitHistory: true,
  changeLog: true,
  lastRankedEncounterId: true,
  rankingReason: true,
});

export const insertDiagnosisSchema = createInsertSchema(diagnoses).pick({
  patientId: true,
  encounterId: true,
  diagnosis: true,
  icd10Code: true,
  diagnosisDate: true,
  status: true,
  notes: true,
});

export const insertPatientPhysicalFindingSchema = createInsertSchema(patientPhysicalFindings).pick({
  patientId: true,
  examSystem: true,
  examComponent: true,
  findingText: true,
  findingType: true,
  confidence: true,
  firstNotedEncounter: true,
  gptReasoning: true,
  clinicalContext: true,
});

// Legacy schema - replaced by userNoteTemplates
// export const insertUserSoapTemplateSchema = createInsertSchema(userSoapTemplates);

export const insertUserEditPatternSchema = createInsertSchema(userEditPatterns).omit({
  id: true,
  createdAt: true,
});

export const insertUserAssistantThreadSchema = createInsertSchema(userAssistantThreads).pick({
  userId: true,
  threadId: true,
  threadType: true,
  isActive: true,
});

// Types
export type InsertUser = z.infer<typeof insertUserSchema>;
export type User = typeof users.$inferSelect;
// Legacy types - replaced by userNoteTemplates
// export type InsertUserSoapTemplate = z.infer<typeof insertUserSoapTemplateSchema>;
// export type UserSoapTemplate = typeof userSoapTemplates.$inferSelect;
export type InsertUserEditPattern = z.infer<typeof insertUserEditPatternSchema>;
export type UserEditPattern = typeof userEditPatterns.$inferSelect;
export type InsertUserAssistantThread = z.infer<typeof insertUserAssistantThreadSchema>;
export type UserAssistantThread = typeof userAssistantThreads.$inferSelect;
export type InsertPatient = z.infer<typeof insertPatientSchema>;
export type Patient = typeof patients.$inferSelect;
export type InsertEncounter = z.infer<typeof insertEncounterSchema>;
export type Encounter = typeof encounters.$inferSelect;

export type Vitals = typeof vitals.$inferSelect;
export type InsertDiagnosis = z.infer<typeof insertDiagnosisSchema>;
export type Diagnosis = typeof diagnoses.$inferSelect;
export const insertMedicationFormularySchema = createInsertSchema(medicationFormulary).pick({
  genericName: true,
  brandNames: true,
  commonNames: true,
  standardStrengths: true,
  availableForms: true,
  formRoutes: true,
  sigTemplates: true,
  commonDoses: true,
  maxDailyDose: true,
  therapeuticClass: true,
  indication: true,
  blackBoxWarning: true,
  ageRestrictions: true,
  prescriptionType: true,
  isControlled: true,
  controlledSchedule: true,
  requiresPriorAuth: true,
  renalAdjustment: true,
  hepaticAdjustment: true,
  prescriptionVolume: true,
  popularityRank: true,
  dataSource: true,
});

export const insertMedicationSchema = createInsertSchema(medications).pick({
  patientId: true,
  encounterId: true,
  medicationName: true,
  brandName: true,
  genericName: true,
  dosage: true,
  strength: true,
  dosageForm: true,
  route: true,
  frequency: true,
  quantity: true,
  daysSupply: true,
  refillsRemaining: true,
  totalRefills: true,
  sig: true,
  rxNormCode: true,
  ndcCode: true,
  sureScriptsId: true,
  clinicalIndication: true,
  problemMappings: true,
  startDate: true,
  endDate: true,
  discontinuedDate: true,
  status: true,
  prescriber: true,
  prescriberId: true,
  firstEncounterId: true,
  lastUpdatedEncounterId: true,
  reasonForChange: true,
  medicationHistory: true,
  changeLog: true,
  groupingStrategy: true,
  relatedMedications: true,
  drugInteractions: true,
  pharmacyOrderId: true,
  insuranceAuthStatus: true,
  priorAuthRequired: true,
});

export type InsertMedication = z.infer<typeof insertMedicationSchema>;
export type Medication = typeof medications.$inferSelect;
export type LabOrder = typeof labOrders.$inferSelect;
export type LabResult = typeof labResults.$inferSelect;
export type LabReferenceRange = typeof labReferenceRanges.$inferSelect;
export type ImagingOrder = typeof imagingOrders.$inferSelect;
export type ImagingResult = typeof imagingResults.$inferSelect;
export type FamilyHistory = typeof familyHistory.$inferSelect;
export type MedicalHistory = typeof medicalHistory.$inferSelect;
export type SocialHistory = typeof socialHistory.$inferSelect;
export type SurgicalHistory = typeof surgicalHistory.$inferSelect;
export type Allergy = typeof allergies.$inferSelect;
export type InsertOrder = z.infer<typeof insertOrderSchema>;
export type Order = typeof orders.$inferSelect;

// Patient Order Preferences schema and types
export const insertPatientOrderPreferencesSchema = createInsertSchema(patientOrderPreferences).pick({
  patientId: true,
  labDeliveryMethod: true,
  labServiceProvider: true,
  imagingDeliveryMethod: true,
  imagingServiceProvider: true,
  medicationDeliveryMethod: true,
  preferredPharmacy: true,
  pharmacyPhone: true,
  pharmacyFax: true,
  lastUpdatedBy: true,
});

export type PatientOrderPreferences = typeof patientOrderPreferences.$inferSelect;
export type InsertPatientOrderPreferences = z.infer<typeof insertPatientOrderPreferencesSchema>;

// Signed Orders schema and types
export const insertSignedOrderSchema = createInsertSchema(signedOrders).pick({
  orderId: true,
  patientId: true,
  encounterId: true,
  orderType: true,
  deliveryMethod: true,
  deliveryStatus: true,
  deliveryAttempts: true,
  lastDeliveryAttempt: true,
  deliveryError: true,
  canChangeDelivery: true,
  deliveryLockReason: true,
  originalDeliveryMethod: true,
  deliveryChanges: true,
  signedAt: true,
  signedBy: true,
});

export type SignedOrder = typeof signedOrders.$inferSelect;
export type InsertSignedOrder = z.infer<typeof insertSignedOrderSchema>;

// Electronic Signature schema and types
export const insertElectronicSignatureSchema = createInsertSchema(electronicSignatures).pick({
  userId: true,
  encounterId: true,
  signatureType: true,
  signatureString: true,
  signatureCanvas: true,
  certificationText: true,
  ipAddress: true,
  userAgent: true,
  authenticationMethod: true,
  twoFactorUsed: true,
  deaSignature: true,
});

export type ElectronicSignature = typeof electronicSignatures.$inferSelect;
export type InsertElectronicSignature = z.infer<typeof insertElectronicSignatureSchema>;

// Pharmacy schema and types
export const insertPharmacySchema = createInsertSchema(pharmacies).pick({
  ncpdpId: true,
  npi: true,
  deaNumber: true,
  googlePlaceId: true,
  name: true,
  dbaName: true,
  corporateName: true,
  address: true,
  address2: true,
  city: true,
  state: true,
  zipCode: true,
  latitude: true,
  longitude: true,
  phone: true,
  fax: true,
  email: true,
  website: true,
  hours: true,
  is24Hour: true,
  services: true,
  acceptsEprescribing: true,
  acceptsControlledSubstances: true,
  preferredTransmissionMethod: true,
  sureScriptsVersion: true,
  specialtyTypes: true,
  insuranceNetworks: true,
  preferredForConditions: true,
  status: true,
  verificationStatus: true,
  lastVerified: true,
  healthSystemId: true,
});

export type Pharmacy = typeof pharmacies.$inferSelect;
export type InsertPharmacy = z.infer<typeof insertPharmacySchema>;

// Prescription Transmission schema and types
export const insertPrescriptionTransmissionSchema = createInsertSchema(prescriptionTransmissions).pick({
  medicationId: true,
  orderId: true,
  patientId: true,
  providerId: true,
  pharmacyId: true,
  transmissionMethod: true,
  transmissionStatus: true,
  surescriptsMessageId: true,
  surescriptsThreadId: true,
  ncpdpVersion: true,
  requestPayload: true,
  responsePayload: true,
  pharmacyResponse: true,
  refillRequestId: true,
  electronicSignatureId: true,
  printedCopy: true,
  faxedCopy: true,
  errorMessage: true,
  retryCount: true,
});

export type PrescriptionTransmission = typeof prescriptionTransmissions.$inferSelect;
export type InsertPrescriptionTransmission = z.infer<typeof insertPrescriptionTransmissionSchema>;

// Patient Attachments
export const patientAttachments = pgTable("patient_attachments", {
  id: serial("id").primaryKey(),
  patientId: integer("patient_id").references(() => patients.id).notNull(),
  encounterId: integer("encounter_id").references(() => encounters.id), // Optional encounter association
  
  // File metadata
  fileName: text("file_name").notNull(),
  originalFileName: text("original_file_name").notNull(),
  fileSize: integer("file_size").notNull(), // bytes
  mimeType: text("mime_type").notNull(),
  fileExtension: text("file_extension").notNull(),
  
  // Storage information
  filePath: text("file_path").notNull(),
  thumbnailPath: text("thumbnail_path"), // For images/PDFs
  
  // Categorization
  category: text("category").notNull().default("general"), // 'lab_results', 'insurance', 'referrals', 'imaging', 'general'
  title: text("title"), // User-provided title
  description: text("description"), // User-provided description
  tags: text("tags").array().default([]), // Search tags
  
  // Security and access
  uploadedBy: integer("uploaded_by").references(() => users.id).notNull(),
  isConfidential: boolean("is_confidential").default(false),
  accessLevel: text("access_level").default("standard"), // 'public', 'standard', 'restricted'
  
  // Duplicate detection
  contentHash: text("content_hash"), // SHA-256 hash of file content for duplicate detection
  
  // Status
  processingStatus: text("processing_status").default("completed"), // 'processing', 'completed', 'failed'
  virusScanStatus: text("virus_scan_status").default("pending"), // 'pending', 'clean', 'infected'
  
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Document Extracted Content
export const attachmentExtractedContent = pgTable("attachment_extracted_content", {
  id: serial("id").primaryKey(),
  attachmentId: integer("attachment_id").references(() => patientAttachments.id).notNull().unique(),
  pageNumber: integer("page_number"),
  contentType: text("content_type").notNull(), // Required by database
  extractedText: text("extracted_text"),
  structuredData: jsonb("structured_data"),
  confidenceScore: decimal("confidence_score", { precision: 5, scale: 2 }),
  extractionMethod: text("extraction_method"),
  aiGeneratedTitle: text("ai_generated_title"),
  documentType: text("document_type"), // "lab_results", "H&P", "discharge_summary", etc.
  processingStatus: text("processing_status").default("pending"), // "pending", "processing", "completed", "failed"
  errorMessage: text("error_message"),
  processedAt: timestamp("processed_at"),
  createdAt: timestamp("created_at").defaultNow(),
});

// Document Processing Queue
export const documentProcessingQueue = pgTable("document_processing_queue", {
  id: serial("id").primaryKey(),
  attachmentId: integer("attachment_id").references(() => patientAttachments.id).notNull(),
  status: text("status").default("queued"), // "queued", "processing", "completed", "failed"
  attempts: integer("attempts").default(0),
  // Removed lastAttempt - doesn't exist in database
  
  // Columns that exist in database
  priority: integer("priority").default(100),
  processorType: text("processor_type").notNull().default("document_analysis"), // Added NOT NULL with default
  processingMetadata: jsonb("processing_metadata"),
  errorMessage: text("error_message"), 
  retryCount: integer("retry_count").default(0),
  startedAt: timestamp("started_at"),
  completedAt: timestamp("completed_at"),
  
  createdAt: timestamp("created_at").defaultNow(),
});

export const insertPatientAttachmentSchema = createInsertSchema(patientAttachments).pick({
  patientId: true,
  encounterId: true,
  fileName: true,
  originalFileName: true,
  fileSize: true,
  mimeType: true,
  fileExtension: true,
  filePath: true,
  thumbnailPath: true,
  category: true,
  title: true,
  description: true,
  tags: true,
  uploadedBy: true,
  isConfidential: true,
  accessLevel: true,
  contentHash: true,
});

export const insertAttachmentExtractedContentSchema = createInsertSchema(attachmentExtractedContent).pick({
  attachmentId: true,
  extractedText: true,
  aiGeneratedTitle: true,
  documentType: true,
  processingStatus: true,
  errorMessage: true,
  processedAt: true,
});

export const insertDocumentProcessingQueueSchema = createInsertSchema(documentProcessingQueue).pick({
  attachmentId: true,
  status: true,
  attempts: true,
  lastAttempt: true,
  priority: true,
  processorType: true,
  processingMetadata: true,
  errorMessage: true,
  retryCount: true,
  startedAt: true,
  completedAt: true,
});

export type PatientAttachment = typeof patientAttachments.$inferSelect;
export type InsertPatientAttachment = z.infer<typeof insertPatientAttachmentSchema>;
export type AttachmentExtractedContent = typeof attachmentExtractedContent.$inferSelect;
export type InsertAttachmentExtractedContent = z.infer<typeof insertAttachmentExtractedContentSchema>;
export type DocumentProcessingQueue = typeof documentProcessingQueue.$inferSelect;
export type InsertDocumentProcessingQueue = z.infer<typeof insertDocumentProcessingQueueSchema>;

// Zod schemas for source tracking fields
export const insertVitalSchema = createInsertSchema(vitals).pick({
  patientId: true,
  encounterId: true,
  recordedAt: true,
  recordedBy: true,
  entryType: true,
  systolicBp: true,
  diastolicBp: true,
  heartRate: true,
  temperature: true,
  weight: true,
  height: true,
  bmi: true,
  oxygenSaturation: true,
  respiratoryRate: true,
  painScale: true,
  notes: true,
  alerts: true,
  parsedFromText: true,
  originalText: true,
  sourceType: true,
  sourceConfidence: true,
  sourceNotes: true,
  extractedFromAttachmentId: true,
  enteredBy: true,
});

export const insertAllergySchema = createInsertSchema(allergies).pick({
  patientId: true,
  allergen: true,
  reaction: true,
  severity: true,
  lastUpdatedEncounterId: true,
  sourceType: true,
  sourceConfidence: true,
  sourceNotes: true,
  extractedFromAttachmentId: true,
  enteredBy: true,
});

export const insertFamilyHistorySchema = createInsertSchema(familyHistory).pick({
  patientId: true,
  relationship: true,
  condition: true,
  lastUpdatedEncounterId: true,
  sourceType: true,
  sourceConfidence: true,
  sourceNotes: true,
  extractedFromAttachmentId: true,
  enteredBy: true,
});

export const insertMedicalHistorySchema = createInsertSchema(medicalHistory).pick({
  patientId: true,
  conditionCategory: true,
  historyText: true,
  lastUpdatedEncounterId: true,
  sourceType: true,
  sourceConfidence: true,
  sourceNotes: true,
  extractedFromAttachmentId: true,
  enteredBy: true,
});

export const insertSocialHistorySchema = createInsertSchema(socialHistory).pick({
  patientId: true,
  category: true,
  currentStatus: true,
  historyNotes: true,
  lastUpdatedEncounterId: true,
  sourceType: true,
  sourceConfidence: true,
  extractedFromAttachmentId: true,
  enteredBy: true,
  consolidationReasoning: true,
  extractionNotes: true,
  visitHistory: true,
});

export const insertSurgicalHistorySchema = createInsertSchema(surgicalHistory).pick({
  patientId: true,
  procedureName: true,
  procedureDate: true,
  surgeonName: true,
  facilityName: true,
  indication: true,
  complications: true,
  outcome: true,
  anesthesiaType: true,
  cptCode: true,
  icd10ProcedureCode: true,
  anatomicalSite: true,
  laterality: true,
  urgencyLevel: true,
  lengthOfStay: true,
  bloodLoss: true,
  transfusionsRequired: true,
  implantsHardware: true,
  followUpRequired: true,
  recoveryStatus: true,
  sourceType: true,
  sourceConfidence: true,
  sourceNotes: true,
  extractedFromAttachmentId: true,
  lastUpdatedEncounterId: true,
  enteredBy: true,
  consolidationReasoning: true,
  extractionNotes: true,
  visitHistory: true,
});

export type InsertVital = z.infer<typeof insertVitalSchema>;
export type Vital = typeof vitals.$inferSelect;
export type InsertAllergy = z.infer<typeof insertAllergySchema>;
export type InsertFamilyHistory = z.infer<typeof insertFamilyHistorySchema>;
export type InsertMedicalHistory = z.infer<typeof insertMedicalHistorySchema>;
export type InsertSocialHistory = z.infer<typeof insertSocialHistorySchema>;
export type InsertSurgicalHistory = z.infer<typeof insertSurgicalHistorySchema>;

// Imaging Results schemas
export const insertImagingResultSchema = createInsertSchema(imagingResults).pick({
  imagingOrderId: true,
  patientId: true,
  studyDate: true,
  modality: true,
  bodyPart: true,
  laterality: true,
  findings: true,
  impression: true,
  readingRadiologist: true,
  performingFacility: true,
  pacsStudyUid: true,
  reportStatus: true,
  sourceType: true,
  sourceConfidence: true,
  extractedFromAttachmentId: true,
  visitHistory: true,
});

export type InsertImagingResult = z.infer<typeof insertImagingResultSchema>;

// Admin prompt management table for viewing/editing generated prompts
export const adminPromptReviews = pgTable("admin_prompt_reviews", {
  id: serial("id").primaryKey(),
  templateId: integer("template_id").references(() => userNoteTemplates.id).notNull(),
  originalPrompt: text("original_prompt").notNull(), // GPT-generated prompt
  reviewedPrompt: text("reviewed_prompt"), // Admin-edited version
  adminUserId: integer("admin_user_id").references(() => users.id), // Who reviewed it
  reviewStatus: text("review_status").default("pending"), // 'pending', 'reviewed', 'approved'
  reviewNotes: text("review_notes"), // Admin comments
  isActive: boolean("is_active").default(false), // Whether to use reviewed version
  performanceMetrics: jsonb("performance_metrics"), // Usage stats, success rates
  createdAt: timestamp("created_at").defaultNow(),
  reviewedAt: timestamp("reviewed_at"),
});

export const insertAdminPromptReviewSchema = createInsertSchema(adminPromptReviews).pick({
  templateId: true,
  originalPrompt: true,
  reviewedPrompt: true,
  adminUserId: true,
  reviewStatus: true,
  reviewNotes: true,
  isActive: true,
  performanceMetrics: true,
});

export type AdminPromptReview = typeof adminPromptReviews.$inferSelect;
export type InsertAdminPromptReview = z.infer<typeof insertAdminPromptReviewSchema>;

// User-specific problem ranking preferences (collaborative system)
export const problemRankOverrides = pgTable("problem_rank_overrides", {
  id: serial("id").primaryKey(),
  problemId: integer("problem_id").references(() => medicalProblems.id, { onDelete: "cascade" }).notNull(),
  userId: integer("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
  preferenceWeight: text("preference_weight").notNull(), // 'low', 'medium', 'high'
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// User display preferences for problem list view
export const userProblemListPreferences = pgTable("user_problem_list_preferences", {
  userId: integer("user_id").primaryKey().references(() => users.id, { onDelete: "cascade" }),
  maxProblemsDisplayed: integer("max_problems_displayed").default(10),
  showResolvedProblems: boolean("show_resolved_problems").default(false),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

export const insertProblemRankOverrideSchema = createInsertSchema(problemRankOverrides).pick({
  problemId: true,
  userId: true,
  preferenceWeight: true,
});

export const insertUserProblemListPreferencesSchema = createInsertSchema(userProblemListPreferences).pick({
  userId: true,
  maxProblemsDisplayed: true,
  showResolvedProblems: true,
});

export type ProblemRankOverride = typeof problemRankOverrides.$inferSelect;
export type InsertProblemRankOverride = z.infer<typeof insertProblemRankOverrideSchema>;
export type UserProblemListPreferences = typeof userProblemListPreferences.$inferSelect;
export type InsertUserProblemListPreferences = z.infer<typeof insertUserProblemListPreferencesSchema>;

// Organizational Structure Relations
export const healthSystemsRelations = relations(healthSystems, ({ many }) => ({
  organizations: many(organizations),
  locations: many(locations), // Direct health system locations
}));

export const organizationsRelations = relations(organizations, ({ one, many }) => ({
  healthSystem: one(healthSystems, {
    fields: [organizations.healthSystemId],
    references: [healthSystems.id],
  }),
  locations: many(locations),
}));

export const locationsRelations = relations(locations, ({ one, many }) => ({
  organization: one(organizations, {
    fields: [locations.organizationId],
    references: [organizations.id],
  }),
  healthSystem: one(healthSystems, {
    fields: [locations.healthSystemId],
    references: [healthSystems.id],
  }),
  userLocations: many(userLocations),
  appointments: many(appointments),
  providerSchedules: many(providerSchedules),
}));

export const userLocationsRelations = relations(userLocations, ({ one }) => ({
  user: one(users, {
    fields: [userLocations.userId],
    references: [users.id],
  }),
  location: one(locations, {
    fields: [userLocations.locationId],
    references: [locations.id],
  }),
}));

export const userSessionLocationsRelations = relations(userSessionLocations, ({ one }) => ({
  user: one(users, {
    fields: [userSessionLocations.userId],
    references: [users.id],
  }),
  location: one(locations, {
    fields: [userSessionLocations.locationId],
    references: [locations.id],
  }),
}));

export const providerSchedulesRelations = relations(providerSchedules, ({ one, many }) => ({
  provider: one(users, {
    fields: [providerSchedules.providerId],
    references: [users.id],
  }),
  location: one(locations, {
    fields: [providerSchedules.locationId],
    references: [locations.id],
  }),
  exceptions: many(scheduleExceptions),
}));

export const scheduleExceptionsRelations = relations(scheduleExceptions, ({ one }) => ({
  provider: one(users, {
    fields: [scheduleExceptions.providerId],
    references: [users.id],
  }),
  location: one(locations, {
    fields: [scheduleExceptions.locationId],
    references: [locations.id],
  }),
  createdByUser: one(users, {
    fields: [scheduleExceptions.createdBy],
    references: [users.id],
  }),
}));

// Enhanced Relations for Existing Tables
export const appointmentsRelationsEnhanced = relations(appointments, ({ one }) => ({
  patient: one(patients, {
    fields: [appointments.patientId],
    references: [patients.id],
  }),
  provider: one(users, {
    fields: [appointments.providerId],
    references: [users.id],
  }),
  location: one(locations, {
    fields: [appointments.locationId],
    references: [locations.id],
  }),
  checkedInByUser: one(users, {
    fields: [appointments.checkedInBy],
    references: [users.id],
  }),
  verifiedByUser: one(users, {
    fields: [appointments.verifiedBy],
    references: [users.id],
  }),
  createdByUser: one(users, {
    fields: [appointments.createdBy],
    references: [users.id],
  }),
}));

export const patientsRelationsEnhanced = relations(patients, ({ one, many }) => ({
  preferredLocation: one(locations, {
    fields: [patients.preferredLocationId],
    references: [locations.id],
  }),
  primaryProvider: one(users, {
    fields: [patients.primaryProviderId],
    references: [users.id],
  }),
  encounters: many(encounters),
  appointments: many(appointments),
  familyHistory: many(familyHistory),
  medicalHistory: many(medicalHistory),
  socialHistory: many(socialHistory),
  surgicalHistory: many(surgicalHistory),
  allergies: many(allergies),
  vitals: many(vitals),
  medications: many(medications),
  diagnoses: many(diagnoses),
  medicalProblems: many(medicalProblems),
  labOrders: many(labOrders),
  labResults: many(labResults),
  imagingOrders: many(imagingOrders),
  imagingResults: many(imagingResults),
  orders: many(orders),
  attachments: many(patientAttachments),
}));

// Insert Schemas for Organizational Structure
export const insertHealthSystemSchema = createInsertSchema(healthSystems).pick({
  name: true,
  shortName: true,
  systemType: true,
  primaryContact: true,
  phone: true,
  email: true,
  website: true,
  npi: true,
  taxId: true,
  logoUrl: true,
  brandColors: true,
});

export const insertOrganizationSchema = createInsertSchema(organizations).pick({
  healthSystemId: true,
  name: true,
  shortName: true,
  organizationType: true,
  region: true,
  city: true,
  state: true,
  zipCode: true,
  phone: true,
  email: true,
  address: true,
  npi: true,
  taxId: true,
});

export const insertLocationSchema = createInsertSchema(locations).pick({
  organizationId: true,
  healthSystemId: true,
  name: true,
  shortName: true,
  locationType: true,
  address: true,
  city: true,
  state: true,
  zipCode: true,
  phone: true,
  fax: true,
  email: true,
  facilityCode: true,
  npi: true,
  operatingHours: true,
  services: true,
  hasLab: true,
  hasImaging: true,
  hasPharmacy: true,
});

export const insertUserLocationSchema = createInsertSchema(userLocations).pick({
  userId: true,
  locationId: true,
  roleAtLocation: true,
  isPrimary: true,
  workSchedule: true,
  canSchedule: true,
  canViewAllPatients: true,
  canCreateOrders: true,
  startDate: true,
  endDate: true,
});

export const insertUserSessionLocationSchema = createInsertSchema(userSessionLocations).pick({
  userId: true,
  locationId: true,
  sessionId: true,
  rememberSelection: true,
});

export const insertAppointmentSchema = createInsertSchema(appointments).pick({
  patientId: true,
  providerId: true,
  locationId: true,
  appointmentDate: true,
  startTime: true,
  endTime: true,
  duration: true,
  appointmentType: true,
  chiefComplaint: true,
  visitReason: true,
  urgencyLevel: true,
  schedulingNotes: true,
  patientPreferences: true,
  aiSchedulingData: true,
  communicationPreferences: true,
  copayAmount: true,
  createdBy: true,
});

export const insertProviderScheduleSchema = createInsertSchema(providerSchedules).pick({
  providerId: true,
  locationId: true,
  dayOfWeek: true,
  startTime: true,
  endTime: true,
  scheduleType: true,
  appointmentTypes: true,
  slotDuration: true,
  bufferTime: true,
  maxConcurrentAppts: true,
  advanceBookingDays: true,
  cancelationPolicyHours: true,
  isAvailableForUrgent: true,
  allowDoubleBooking: true,
  requiresReferral: true,
  effectiveFrom: true,
  effectiveUntil: true,
});

export const insertScheduleExceptionSchema = createInsertSchema(scheduleExceptions).pick({
  providerId: true,
  locationId: true,
  exceptionDate: true,
  startTime: true,
  endTime: true,
  exceptionType: true,
  reason: true,
  cancelsExistingAppts: true,
  allowsEmergencyOverride: true,
  isRecurring: true,
  recurrencePattern: true,
  createdBy: true,
});

// Types for Organizational Structure
export type HealthSystem = typeof healthSystems.$inferSelect;
export type InsertHealthSystem = z.infer<typeof insertHealthSystemSchema>;
export type Organization = typeof organizations.$inferSelect;
export type InsertOrganization = z.infer<typeof insertOrganizationSchema>;
export type Location = typeof locations.$inferSelect;
export type InsertLocation = z.infer<typeof insertLocationSchema>;
export type UserLocation = typeof userLocations.$inferSelect;
export type InsertUserLocation = z.infer<typeof insertUserLocationSchema>;
export type UserSessionLocation = typeof userSessionLocations.$inferSelect;
export type InsertUserSessionLocation = z.infer<typeof insertUserSessionLocationSchema>;
export type Appointment = typeof appointments.$inferSelect;
export type InsertAppointment = z.infer<typeof insertAppointmentSchema>;
export type ProviderSchedule = typeof providerSchedules.$inferSelect;
export type InsertProviderSchedule = z.infer<typeof insertProviderScheduleSchema>;
export type ScheduleException = typeof scheduleExceptions.$inferSelect;
export type InsertScheduleException = z.infer<typeof insertScheduleExceptionSchema>;

// User Preferences Types
// Removed orphaned UserPreferences types - chartPanelWidth moved to userNotePreferences

// Migration Invitations table
export const migrationInvitations = pgTable('migration_invitations', {
  id: serial('id').primaryKey(),
  
  // Who is being invited
  invitedUserId: integer('invited_user_id').references(() => users.id),
  invitedUserEmail: text('invited_user_email').notNull(), // For inviting users not yet in system
  
  // Which health system is inviting them
  targetHealthSystemId: integer('target_health_system_id').notNull().references(() => healthSystems.id),
  
  // Who created the invitation (admin of target health system)
  createdByUserId: integer('created_by_user_id').notNull().references(() => users.id),
  
  // Invitation details
  invitationCode: text('invitation_code').notNull().unique(), // Secure random code
  message: text('message'), // Optional message from inviting organization
  
  // Status tracking
  status: text('status').notNull().default('pending'), // pending, accepted, rejected, expired
  expiresAt: timestamp('expires_at').notNull(),
  acceptedAt: timestamp('accepted_at'),
  rejectedAt: timestamp('rejected_at'),
  
  // Audit
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
});

// Insert schema for migration invitations
export const insertMigrationInvitationSchema = createInsertSchema(migrationInvitations)
  .omit({
    id: true,
    createdAt: true,
    updatedAt: true,
  })
  .extend({
    invitedUserEmail: z.string().email(),
    status: z.enum(['pending', 'accepted', 'rejected', 'expired']).default('pending'),
  });

export type MigrationInvitation = typeof migrationInvitations.$inferSelect;
export type InsertMigrationInvitation = z.infer<typeof insertMigrationInvitationSchema>;

// Subscription Keys System Tables

// Subscription keys for tier-based access
export const subscriptionKeys = pgTable("subscription_keys", {
  id: serial("id").primaryKey(),
  key: varchar("key", { length: 20 }).unique().notNull(),
  healthSystemId: integer("health_system_id").notNull().references(() => healthSystems.id),
  keyType: text("key_type").notNull(), // 'provider', 'staff', 'admin'
  subscriptionTier: integer("subscription_tier").notNull(), // 1, 2, 3
  status: text("status").default("active"), // 'active', 'used', 'expired', 'deactivated'
  monthlyPrice: decimal("monthly_price", { precision: 10, scale: 2 }), // Per-user monthly price
  createdAt: timestamp("created_at").defaultNow(),
  expiresAt: timestamp("expires_at").notNull(), // 72 hours from creation for unused keys
  usedBy: integer("used_by").references(() => users.id),
  usedAt: timestamp("used_at"),
  deactivatedBy: integer("deactivated_by").references(() => users.id),
  deactivatedAt: timestamp("deactivated_at"),
  metadata: jsonb("metadata").$type<{
    regenerationCount?: number;
    notes?: string;
    [key: string]: any;
  }>().default({}),
});

// Subscription history for tracking changes and grace periods
export const subscriptionHistory = pgTable("subscription_history", {
  id: serial("id").primaryKey(),
  healthSystemId: integer("health_system_id").notNull().references(() => healthSystems.id),
  previousTier: integer("previous_tier"),
  newTier: integer("new_tier"),
  changeType: text("change_type"), // 'upgrade', 'downgrade', 'expire', 'reactivate'
  changedAt: timestamp("changed_at").defaultNow(),
  gracePeriodEnds: timestamp("grace_period_ends"),
  dataExpiresAt: timestamp("data_expires_at"), // 30 days after grace period ends
  metadata: jsonb("metadata").$type<{
    reason?: string;
    adminNotes?: string;
    [key: string]: any;
  }>().default({}),
});

// Email notifications tracking
export const emailNotifications = pgTable("email_notifications", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id),
  healthSystemId: integer("health_system_id").references(() => healthSystems.id),
  notificationType: varchar("notification_type", { length: 50 }).notNull(),
  sentAt: timestamp("sent_at").defaultNow(),
  emailAddress: varchar("email_address", { length: 255 }).notNull(),
  subject: text("subject"),
  metadata: jsonb("metadata").$type<{
    templateUsed?: string;
    sendStatus?: string;
    [key: string]: any;
  }>().default({}),
});

// Clinic administrator verification requests
export const clinicAdminVerifications = pgTable("clinic_admin_verifications", {
  id: serial("id").primaryKey(),
  email: text("email").notNull(),
  organizationName: text("organization_name").notNull(),
  verificationCode: text("verification_code").notNull(),
  verificationData: jsonb("verification_data").notNull(), // Full request data
  status: text("status").default('pending'), // 'pending', 'approved', 'rejected', 'expired'
  healthSystemId: integer("health_system_id").references(() => healthSystems.id),
  submittedAt: timestamp("submitted_at").defaultNow(),
  approvedAt: timestamp("approved_at"),
  rejectedAt: timestamp("rejected_at"),
  rejectionReason: text("rejection_reason"),
  expiresAt: timestamp("expires_at").notNull(),
  approvedBy: integer("approved_by").references(() => users.id),
  ipAddress: text("ip_address"),
  userAgent: text("user_agent")
});

// Organization verification documents
export const organizationDocuments = pgTable("organization_documents", {
  id: serial("id").primaryKey(),
  healthSystemId: integer("health_system_id").references(() => healthSystems.id).notNull(),
  documentType: text("document_type").notNull(), // 'baa', 'business_license', 'medical_license', 'insurance', 'tax_exempt'
  documentUrl: text("document_url").notNull(),
  documentName: text("document_name"),
  uploadedAt: timestamp("uploaded_at").defaultNow(),
  uploadedBy: integer("uploaded_by").references(() => users.id),
  verifiedAt: timestamp("verified_at"),
  verifiedBy: integer("verified_by").references(() => users.id),
  expiresAt: timestamp("expires_at"), // For licenses that expire
  metadata: jsonb("metadata")
});

// Insert schemas for new tables
export const insertSubscriptionKeySchema = createInsertSchema(subscriptionKeys).pick({
  key: true,
  healthSystemId: true,
  keyType: true,
  subscriptionTier: true,
  expiresAt: true,
  metadata: true,
});

export const insertSubscriptionHistorySchema = createInsertSchema(subscriptionHistory).pick({
  healthSystemId: true,
  previousTier: true,
  newTier: true,
  changeType: true,
  gracePeriodEnds: true,
  dataExpiresAt: true,
  metadata: true,
});

export const insertEmailNotificationSchema = createInsertSchema(emailNotifications).pick({
  userId: true,
  healthSystemId: true,
  notificationType: true,
  emailAddress: true,
  subject: true,
  metadata: true,
});

// Export types
export type SubscriptionKey = typeof subscriptionKeys.$inferSelect;
export type InsertSubscriptionKey = z.infer<typeof insertSubscriptionKeySchema>;
export type SubscriptionHistory = typeof subscriptionHistory.$inferSelect;
export type InsertSubscriptionHistory = z.infer<typeof insertSubscriptionHistorySchema>;
export type EmailNotification = typeof emailNotifications.$inferSelect;
export type InsertEmailNotification = z.infer<typeof insertEmailNotificationSchema>;

// Insert schemas for verification tables
export const insertClinicAdminVerificationSchema = createInsertSchema(clinicAdminVerifications).pick({
  email: true,
  organizationName: true,
  verificationCode: true,
  verificationData: true,
  expiresAt: true,
  ipAddress: true,
  userAgent: true
});

export const insertOrganizationDocumentSchema = createInsertSchema(organizationDocuments).pick({
  healthSystemId: true,
  documentType: true,
  documentUrl: true,
  documentName: true,
  uploadedBy: true,
  expiresAt: true,
  metadata: true
});

// Export types for verification tables
export type ClinicAdminVerification = typeof clinicAdminVerifications.$inferSelect;
export type InsertClinicAdminVerification = z.infer<typeof insertClinicAdminVerificationSchema>;
export type OrganizationDocument = typeof organizationDocuments.$inferSelect;
export type InsertOrganizationDocument = z.infer<typeof insertOrganizationDocumentSchema>;

// Subscription keys relations
export const subscriptionKeysRelations = relations(subscriptionKeys, ({ one }) => ({
  healthSystem: one(healthSystems, {
    fields: [subscriptionKeys.healthSystemId],
    references: [healthSystems.id],
  }),
  usedByUser: one(users, {
    fields: [subscriptionKeys.usedBy],
    references: [users.id],
  }),
  deactivatedByUser: one(users, {
    fields: [subscriptionKeys.deactivatedBy],
    references: [users.id],
  }),
}));

// Subscription history relations
export const subscriptionHistoryRelations = relations(subscriptionHistory, ({ one }) => ({
  healthSystem: one(healthSystems, {
    fields: [subscriptionHistory.healthSystemId],
    references: [healthSystems.id],
  }),
}));

// Email notifications relations
export const emailNotificationsRelations = relations(emailNotifications, ({ one }) => ({
  user: one(users, {
    fields: [emailNotifications.userId],
    references: [users.id],
  }),
  healthSystem: one(healthSystems, {
    fields: [emailNotifications.healthSystemId],
    references: [healthSystems.id],
  }),
}));

// Clinic admin verifications relations
export const clinicAdminVerificationsRelations = relations(clinicAdminVerifications, ({ one }) => ({
  healthSystem: one(healthSystems, {
    fields: [clinicAdminVerifications.healthSystemId],
    references: [healthSystems.id],
  }),
  approvedByUser: one(users, {
    fields: [clinicAdminVerifications.approvedBy],
    references: [users.id],
  }),
}));

// Organization documents relations
export const organizationDocumentsRelations = relations(organizationDocuments, ({ one }) => ({
  healthSystem: one(healthSystems, {
    fields: [organizationDocuments.healthSystemId],
    references: [healthSystems.id],
  }),
  uploadedByUser: one(users, {
    fields: [organizationDocuments.uploadedBy],
    references: [users.id],
  }),
  verifiedByUser: one(users, {
    fields: [organizationDocuments.verifiedBy],
    references: [users.id],
  }),
}));

// Migration invitations relations
export const migrationInvitationsRelations = relations(migrationInvitations, ({ one }) => ({
  invitedUser: one(users, {
    fields: [migrationInvitations.invitedUserId],
    references: [users.id],
  }),
  targetHealthSystem: one(healthSystems, {
    fields: [migrationInvitations.targetHealthSystemId],
    references: [healthSystems.id],
  }),
  createdByUser: one(users, {
    fields: [migrationInvitations.createdByUserId],
    references: [users.id],
  }),
}));

// ============================================
// HIPAA AUDIT LOGGING TABLES
// ============================================
// Comprehensive audit logging for HIPAA compliance
// Must track all PHI access, modifications, and authentication events

/**
 * PHI Access Audit Log
 * Tracks every access to patient health information
 * Required for HIPAA compliance - minimum 6 year retention
 */
export const phiAccessLogs = pgTable("phi_access_logs", {
  id: serial("id").primaryKey(),
  
  // Who accessed the data
  userId: integer("user_id").references(() => users.id).notNull(),
  userName: text("user_name").notNull(), // Denormalized for immutability
  userRole: text("user_role").notNull(), // Denormalized for immutability
  healthSystemId: integer("health_system_id").references(() => healthSystems.id).notNull(),
  locationId: integer("location_id").references(() => locations.id),
  
  // What was accessed
  patientId: integer("patient_id").references(() => patients.id),
  patientName: text("patient_name"), // Denormalized for immutability (encrypted)
  resourceType: text("resource_type").notNull(), // 'patient', 'encounter', 'medication', 'lab_result', etc.
  resourceId: integer("resource_id").notNull(),
  
  // How it was accessed
  action: text("action").notNull(), // 'view', 'create', 'update', 'delete', 'print', 'export'
  accessMethod: text("access_method").notNull(), // 'web', 'api', 'mobile', 'report'
  httpMethod: text("http_method"), // GET, POST, PUT, DELETE
  apiEndpoint: text("api_endpoint"), // /api/patients/:id
  
  // Context
  ipAddress: text("ip_address").notNull(),
  userAgent: text("user_agent"),
  sessionId: text("session_id"),
  
  // Result
  success: boolean("success").notNull(),
  errorMessage: text("error_message"),
  responseTime: integer("response_time"), // milliseconds
  
  // Additional compliance data
  accessReason: text("access_reason"), // 'treatment', 'payment', 'operations', 'patient_request'
  emergencyAccess: boolean("emergency_access").default(false),
  breakGlassReason: text("break_glass_reason"), // For emergency override access
  
  // Immutable timestamp
  accessedAt: timestamp("accessed_at").defaultNow().notNull(),
});

/**
 * Authentication Audit Log
 * Tracks all authentication attempts and session events
 */
export const authenticationLogs = pgTable("authentication_logs", {
  id: serial("id").primaryKey(),
  
  // User info (may be null for failed login attempts)
  userId: integer("user_id").references(() => users.id),
  username: text("username").notNull(),
  email: text("email"),
  healthSystemId: integer("health_system_id").references(() => healthSystems.id),
  
  // Event details
  eventType: text("event_type").notNull(), // 'login_attempt', 'login_success', 'login_failure', 'logout', 'session_timeout', 'password_change', 'mfa_challenge', 'account_locked'
  success: boolean("success").notNull(),
  failureReason: text("failure_reason"), // 'invalid_password', 'account_locked', 'mfa_failed', etc.
  
  // Security info
  ipAddress: text("ip_address").notNull(),
  userAgent: text("user_agent"),
  browserInfo: text("browser_info"), // Browser name, version, etc.
  deviceInfo: text("device_info"), // Device type, OS, etc.
  geolocation: jsonb("geolocation").$type<{
    country?: string;
    region?: string;
    city?: string;
    latitude?: number;
    longitude?: number;
  }>(),
  
  // Session info
  sessionId: text("session_id"),
  sessionDuration: integer("session_duration"), // seconds
  logoutType: text("logout_type"), // 'manual', 'timeout', 'forced', etc.
  logoutReason: text("logout_reason"), // Reason for logout if applicable
  
  // MFA info
  mfaType: text("mfa_type"), // 'totp', 'sms', 'email'
  mfaSuccess: boolean("mfa_success"),
  
  // Risk assessment
  riskScore: integer("risk_score"), // 0-100
  riskFactors: text("risk_factors").array(), // ['new_device', 'unusual_location', 'multiple_failures']
  
  // Immutable timestamp
  eventTime: timestamp("event_time").defaultNow().notNull(),
});

// Authentication log insert schema and types
export const insertAuthenticationLogSchema = createInsertSchema(authenticationLogs).pick({
  userId: true,
  username: true,
  email: true,
  healthSystemId: true,
  eventType: true,
  success: true,
  failureReason: true,
  ipAddress: true,
  userAgent: true,
  browserInfo: true,
  deviceInfo: true,
  geolocation: true,
  sessionId: true,
  sessionDuration: true,
  logoutType: true,
  logoutReason: true,
  mfaType: true,
  mfaSuccess: true,
  riskScore: true,
  riskFactors: true,
});

export type AuthenticationLog = typeof authenticationLogs.$inferSelect;
export type InsertAuthenticationLog = z.infer<typeof insertAuthenticationLogSchema>;

/**
 * Data Modification Audit Log
 * Tracks all changes to clinical data
 */
export const dataModificationLogs = pgTable("data_modification_logs", {
  id: serial("id").primaryKey(),
  
  // Who made the change
  userId: integer("user_id").references(() => users.id).notNull(),
  userName: text("user_name").notNull(), // Denormalized
  userRole: text("user_role").notNull(), // Denormalized
  healthSystemId: integer("health_system_id").references(() => healthSystems.id).notNull(),
  
  // What was changed
  tableName: text("table_name").notNull(),
  recordId: integer("record_id").notNull(),
  patientId: integer("patient_id").references(() => patients.id), // If applicable
  
  // Change details
  operation: text("operation").notNull(), // 'insert', 'update', 'delete'
  fieldName: text("field_name"), // For updates, which field changed
  oldValue: jsonb("old_value"), // Previous value (encrypted if PHI)
  newValue: jsonb("new_value"), // New value (encrypted if PHI)
  
  // Context
  changeReason: text("change_reason"), // User-provided reason for change
  encounterId: integer("encounter_id").references(() => encounters.id),
  orderAuthority: text("order_authority"), // For order-related changes
  
  // Validation
  validated: boolean("validated").default(false),
  validatedBy: integer("validated_by").references(() => users.id),
  validatedAt: timestamp("validated_at"),
  
  // Immutable timestamp
  modifiedAt: timestamp("modified_at").defaultNow().notNull(),
});

/**
 * Emergency Access Log
 * Special logging for break-glass emergency access scenarios
 */
export const emergencyAccessLogs = pgTable("emergency_access_logs", {
  id: serial("id").primaryKey(),
  
  // Who accessed
  userId: integer("user_id").references(() => users.id).notNull(),
  userName: text("user_name").notNull(),
  userRole: text("user_role").notNull(),
  healthSystemId: integer("health_system_id").references(() => healthSystems.id).notNull(),
  
  // What was accessed
  patientId: integer("patient_id").references(() => patients.id).notNull(),
  patientName: text("patient_name").notNull(), // Encrypted
  
  // Emergency details
  emergencyType: text("emergency_type").notNull(), // 'life_threatening', 'urgent_care', 'disaster_response'
  justification: text("justification").notNull(), // Required detailed explanation
  authorizingPhysician: text("authorizing_physician"),
  
  // Access scope
  accessStartTime: timestamp("access_start_time").defaultNow().notNull(),
  accessEndTime: timestamp("access_end_time"),
  accessedResources: jsonb("accessed_resources").$type<Array<{
    resourceType: string;
    resourceId: number;
    accessTime: string;
  }>>().default([]),
  
  // Review process
  reviewRequired: boolean("review_required").default(true),
  reviewedBy: integer("reviewed_by").references(() => users.id),
  reviewedAt: timestamp("reviewed_at"),
  reviewOutcome: text("review_outcome"), // 'approved', 'violation_found', 'additional_training_required'
  reviewNotes: text("review_notes"),
  
  createdAt: timestamp("created_at").defaultNow(),
});

/**
 * Magic Links for passwordless authentication
 * Stores temporary tokens for email-based authentication
 */
export const magicLinks = pgTable("magic_links", {
  id: serial("id").primaryKey(),
  
  // User association (null for registration links)
  userId: integer("user_id").references(() => users.id),
  email: text("email").notNull(),
  
  // Token details
  token: text("token").notNull().unique(),
  purpose: text("purpose").notNull(), // 'login', 'registration', 'password_reset'
  
  // Expiration and usage
  expiresAt: timestamp("expires_at").notNull(),
  usedAt: timestamp("used_at"),
  
  // Security tracking
  ipAddress: text("ip_address"),
  userAgent: text("user_agent"),
  
  // Timestamps
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

/**
 * WebAuthn Credentials for Passkey Authentication
 * Stores passkey credentials for users enabling passwordless authentication
 */
export const webauthnCredentials = pgTable("webauthn_credentials", {
  id: serial("id").primaryKey(),
  
  // User association
  userId: integer("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
  
  // Credential details
  credentialId: text("credential_id").unique().notNull(),
  credentialPublicKey: text("credential_public_key").notNull(),
  counter: integer("counter").default(0).notNull(),
  
  // Device information
  deviceType: text("device_type"),
  transports: jsonb("transports").$type<string[]>(),
  registeredDevice: text("registered_device"),
  
  // Metadata
  displayName: text("display_name"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  lastUsedAt: timestamp("last_used_at")
}, (table) => ({
  userIdx: index("webauthn_credentials_user_idx").on(table.userId),
  credentialIdx: index("webauthn_credentials_credential_idx").on(table.credentialId),
  createdIdx: index("webauthn_credentials_created_idx").on(table.createdAt)
}));

// Blog/Article System Tables
export const articles = pgTable("articles", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  slug: text("slug").notNull().unique(),
  content: text("content").notNull(),
  excerpt: text("excerpt"),
  category: text("category").notNull(),
  status: text("status").notNull().default("draft"), // draft, review, published, archived
  authorName: text("author_name").default("Clarafi Team"),
  featuredImage: text("featured_image"),
  metaTitle: text("meta_title"),
  metaDescription: text("meta_description"),
  keywords: text("keywords").array(),
  targetAudience: text("target_audience"), // physician, administrator, ceo
  readingTime: integer("reading_time"), // in minutes
  viewCount: integer("view_count").default(0),
  publishedAt: timestamp("published_at"),
  scheduledFor: timestamp("scheduled_for"),
  generatedAt: timestamp("generated_at").defaultNow(),
  reviewedAt: timestamp("reviewed_at"),
  reviewedBy: integer("reviewed_by").references(() => users.id),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

export const articleRevisions = pgTable("article_revisions", {
  id: serial("id").primaryKey(),
  articleId: integer("article_id").notNull().references(() => articles.id, { onDelete: "cascade" }),
  content: text("content").notNull(),
  revisionNote: text("revision_note"),
  revisionType: text("revision_type"), // ai_edit, manual_edit, ai_feedback
  createdBy: integer("created_by").references(() => users.id),
  createdAt: timestamp("created_at").defaultNow(),
});

export const articleComments = pgTable("article_comments", {
  id: serial("id").primaryKey(),
  articleId: integer("article_id").notNull().references(() => articles.id, { onDelete: "cascade" }),
  authorName: text("author_name").notNull(),
  authorEmail: text("author_email").notNull(),
  content: text("content").notNull(),
  isApproved: boolean("is_approved").default(false),
  parentId: integer("parent_id").references(() => articleComments.id),
  createdAt: timestamp("created_at").defaultNow(),
});

export const articleGenerationQueue = pgTable("article_generation_queue", {
  id: serial("id").primaryKey(),
  topic: text("topic"),
  category: text("category").notNull(),
  targetAudience: text("target_audience").notNull(),
  keywords: text("keywords").array(),
  competitorMentions: text("competitor_mentions").array(),
  customPrompt: text("custom_prompt"), // For misc category custom prompts
  researchSources: jsonb("research_sources"), // URLs and snippets from web search
  status: text("status").notNull().default("pending"), // pending, generating, completed, failed
  generatedArticleId: integer("generated_article_id").references(() => articles.id),
  error: text("error"),
  createdAt: timestamp("created_at").defaultNow(),
  processedAt: timestamp("processed_at"),
});

export const newsletterSubscribers = pgTable("newsletter_subscribers", {
  id: serial("id").primaryKey(),
  email: text("email").notNull().unique(),
  name: text("name"),
  subscribedAt: timestamp("subscribed_at").defaultNow(),
  unsubscribedAt: timestamp("unsubscribed_at"),
  preferences: jsonb("preferences"), // categories they're interested in
  source: text("source"), // blog, landing_page, etc
});

// Blog/Article System Types and Schemas
