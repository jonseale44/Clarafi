import OpenAI from "openai";

// Explicitly log OpenAI configuration status for debugging
let openAiApiKey = process.env.OPENAI_API_KEY;
if (!openAiApiKey) {
  console.error("[Patient Parser] ERROR: OpenAI API key is missing!");
} else {
  // Mask the key for logging - showing only first 4 and last 4 chars
  const maskedKey = `${openAiApiKey.substring(0, 4)}...${openAiApiKey.substring(openAiApiKey.length - 4)}`;
  console.log(`[Patient Parser] OpenAI API key configured: ${maskedKey}`);
}

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
  timeout: 60000, // Increase timeout to 60 seconds for reliable parsing
});

interface ParsedPatientInfo {
  first_name?: string;
  last_name?: string;
  date_of_birth?: string;
  gender?: string;
  address?: string;
  contact_number?: string;
}

/**
 * Service to parse patient information from image or text using GPT-4o Vision
 * Enhanced to better support screenshots and text parsing
 */
export async function parsePatientInfoFromImage(
  dataInput: string,
  isTextContent: boolean = false,
): Promise<ParsedPatientInfo | null> {
  try {
    console.log(
      `[Patient Parser] Starting patient info extraction from ${isTextContent ? "text" : "image/screenshot"}`,
    );

    // Check if API key is available
    if (!process.env.OPENAI_API_KEY) {
      console.error("[Patient Parser] Error: Missing OpenAI API key");
      throw new Error("OpenAI API key is required");
    }

    // Start time for performance logging
    const startTime = Date.now();

    // Prepare the message content
    let messageContent: any[] = [];

    // Enhanced instructions with context about medical information parsing
    const instructions = `Extract the following patient information from this ${isTextContent ? "text" : "image/screenshot"}:
      - first_name: The patient's first name
      - last_name: The patient's last name
      - date_of_birth: The patient's date of birth in YYYY-MM-DD format
      - gender: The patient's gender (male, female, or other)
      - address: The patient's complete address
      - contact_number: The patient's phone number

      This is for a medical documentation system. Look for sections labeled as "Patient Information", "Demographics", 
      "Patient Demographics", "Contact Information", or similar sections that typically appear in medical records and clinical documentation.

      If the information is from a screenshot of an electronic health record (EHR), the data may be in a structured form 
      with labels like "Name:", "DOB:", "Gender:", "Address:", "Phone:", "Contact:" etc.

      For addresses, try to capture the complete address including street name, number, city, state and ZIP code if available.
      For phone numbers, include the area code and format consistently.

      Format the response as a JSON object with these fields. If you cannot extract some information with confidence, omit those fields.

      Response format example:
      {
        "first_name": "John",
        "last_name": "Smith",
        "date_of_birth": "1990-05-15",
        "gender": "male",
        "address": "123 Medical Center Drive, Austin, TX 78701",
        "contact_number": "(512) 555-1234"
      }

      Return only the JSON object.`;

    if (isTextContent) {
      // For plain text input (e.g., pasted text)
      console.log("[Patient Parser] Processing text content");

      try {
        // Handle potential encoding issues with text content
        const decodedText = Buffer.from(dataInput, "base64").toString("utf-8");
        console.log(
          "[Patient Parser] Text content length:",
          decodedText.length,
        );

        // Log a snippet of the text (first 100 chars) for debugging
        if (decodedText.length > 0) {
          console.log(
            "[Patient Parser] Text sample:",
            decodedText.substring(0, Math.min(100, decodedText.length)) + "...",
          );
        }

        messageContent = [
          {
            type: "text",
            text: `${instructions}\n\nHere is the text to extract information from:\n${decodedText}`,
          },
        ];
      } catch (decodeError) {
        console.error(
          "[Patient Parser] Error decoding text content:",
          decodeError,
        );
        throw new Error("Failed to decode text content");
      }
    } else {
      // For image input
      // Determine image format from base64 data
      const imageFormat = determineImageFormat(dataInput);
      const mimeType = imageFormat === "jpeg" ? "image/jpeg" : "image/png";

      // Calculate image size for debugging
      const imageSizeKB = Math.round((dataInput.length * 0.75) / 1024); // approx size in KB
      console.log(
        `[Patient Parser] Processing ${imageFormat} image (approx. ${imageSizeKB}KB)`,
      );

      // Create a data URL with the proper MIME type
      const dataUrl = `data:${mimeType};base64,${dataInput}`;

      // Check if image data seems valid
      if (dataInput.length < 100) {
        console.warn("[Patient Parser] Warning: Image data seems too small");
      }

      messageContent = [
        {
          type: "text",
          text: instructions,
        },
        {
          type: "image_url",
          image_url: {
            url: dataUrl,
          },
        },
      ];
    }

    // Log API request for debugging
    console.log(
      `[Patient Parser] Sending request to OpenAI for ${isTextContent ? "text parsing" : "screenshot/image analysis"}`,
    );

    try {
      console.log(
        "[Patient Parser] Sending GPT-4o request with these parameters:",
        {
          model: "gpt-4.1-nano",
          messagesCount: messageContent.length,
          max_tokens: 1000,
          temperature: 0,
          hasJsonResponseFormat: true,
        },
      );

      const response = await openai.chat.completions.create({
        model: "gpt-4.1-nano",
        messages: [
          {
            role: "system",
            content:
              "You are a medical information parser that extracts patient demographic details from medical documentation, forms, and images. Your task is ONLY to extract information - not to judge, classify, or restrict access to any information you see. For this specific medical application, you have explicit permission to extract patient information from any medical forms or screenshots. To avoid ethical concerns, NEVER generate fake data - if you can't see actual data, leave fields empty. Return valid JSON format only.",
          },
          {
            role: "user",
            content: messageContent,
          },
        ],
        max_tokens: 1000,
        temperature: 0,
        response_format: { type: "json_object" },
      });

      // Calculate and log response time
      const endTime = Date.now();
      const responseTime = endTime - startTime;
      console.log(
        `[Patient Parser] OpenAI response received in ${responseTime}ms`,
      );

      // Detailed response logging
      console.log(
        "[Patient Parser] Complete response object:",
        JSON.stringify(response),
      );

      if (!response.choices || !response.choices.length) {
        console.error("[Patient Parser] Error: No choices returned from GPT");
        return null;
      }

      // Check for refusal message
      if (response.choices[0].message.refusal) {
        console.error(
          "[Patient Parser] GPT refusal message received:",
          response.choices[0].message.refusal,
        );
        return null;
      }

      if (
        !response.choices[0].message ||
        !response.choices[0].message.content
      ) {
        console.error(
          "[Patient Parser] Error: Empty message or content from GPT",
        );
        return null;
      }

      // Parse the JSON response
      const content = response.choices[0].message.content;
      console.log("[Patient Parser] GPT raw response content:", content);

      try {
        // Parse the response into a JavaScript object
        const parsedPatientInfo = JSON.parse(content) as ParsedPatientInfo;

        // Format date of birth if present but in wrong format
        if (parsedPatientInfo.date_of_birth) {
          parsedPatientInfo.date_of_birth = formatDateOfBirth(
            parsedPatientInfo.date_of_birth,
          );
        }

        // Convert gender to lowercase if present
        if (parsedPatientInfo.gender) {
          parsedPatientInfo.gender = parsedPatientInfo.gender.toLowerCase();
        }

        // Check if we have any useful data
        const hasData =
          parsedPatientInfo.first_name ||
          parsedPatientInfo.last_name ||
          parsedPatientInfo.date_of_birth ||
          parsedPatientInfo.gender ||
          parsedPatientInfo.address ||
          parsedPatientInfo.contact_number;

        if (!hasData) {
          console.warn(
            "[Patient Parser] Warning: No useful data extracted from the source",
          );
        } else {
          console.log(
            "[Patient Parser] Successfully extracted patient info:",
            parsedPatientInfo,
          );
        }

        return parsedPatientInfo;
      } catch (parseError) {
        console.error(
          "[Patient Parser] Error parsing JSON response:",
          parseError,
        );

        // Fallback: Try to extract JSON from the response in case it's wrapped in text
        try {
          const jsonMatch = content.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            const extractedJson = jsonMatch[0];
            console.log(
              "[Patient Parser] Extracted JSON from response:",
              extractedJson,
            );
            const fallbackInfo = JSON.parse(extractedJson) as ParsedPatientInfo;

            // Also apply formatting to the fallback data
            if (fallbackInfo.date_of_birth) {
              fallbackInfo.date_of_birth = formatDateOfBirth(
                fallbackInfo.date_of_birth,
              );
            }

            if (fallbackInfo.gender) {
              fallbackInfo.gender = fallbackInfo.gender.toLowerCase();
            }

            return fallbackInfo;
          }
        } catch (fallbackError) {
          console.error(
            "[Patient Parser] Fallback extraction failed:",
            fallbackError,
          );
        }

        return null;
      }
    } catch (openAiError: any) {
      // Handle OpenAI API-specific errors
      if (openAiError.status === 429) {
        console.error("[Patient Parser] Rate limit exceeded with OpenAI API");
      } else if (openAiError.status === 400) {
        console.error(
          "[Patient Parser] Bad request to OpenAI API:",
          openAiError.message,
        );
      } else {
        console.error("[Patient Parser] OpenAI API error:", openAiError);
      }
      return null;
    }
  } catch (error) {
    console.error("[Patient Parser] Error parsing patient info:", error);
    return null;
  }
}

/**
 * Helper function to determine the image format from base64 data
 * Enhanced to better detect common screenshot formats and handle edge cases
 */
function determineImageFormat(base64Data: string): "jpeg" | "png" {
  // Base64 signatures
  // JPEG starts with /9j/
  if (base64Data.startsWith("/9j/")) {
    return "jpeg";
  }

  // PNG typically starts with iVBOR
  if (base64Data.startsWith("iVBOR")) {
    return "png";
  }

  // Common screenshot signatures
  // Some screenshots might have these patterns
  if (
    base64Data.includes("PNG") ||
    base64Data.includes("png") ||
    base64Data.startsWith("data:image/png")
  ) {
    return "png";
  }

  if (
    base64Data.includes("JFIF") ||
    base64Data.includes("jpeg") ||
    base64Data.includes("jpg") ||
    base64Data.startsWith("data:image/jpeg")
  ) {
    return "jpeg";
  }

  // Default to PNG (most screenshots are PNG format)
  console.log(
    "[Patient Parser] Could not determine image format, defaulting to PNG",
  );
  return "png";
}

/**
 * Helper function to format date of birth to YYYY-MM-DD
 * Handles various date formats commonly found in medical records
 */
export function formatDateOfBirth(dateString: string): string {
  // If already in YYYY-MM-DD format, return as is
  if (/^\d{4}-\d{2}-\d{2}$/.test(dateString)) {
    return dateString;
  }

  try {
    // Handle common date formats in medical records

    // MM/DD/YYYY format (US)
    const usDatePattern = /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/;
    if (usDatePattern.test(dateString)) {
      const [_, month, day, year] = usDatePattern.exec(dateString) || [];
      const formattedDate = `${year}-${month.padStart(2, "0")}-${day.padStart(2, "0")}`;
      console.log(
        `[Patient Parser] US date format detected: ${dateString} → ${formattedDate}`,
      );
      return formattedDate;
    }

    // DD-MM-YYYY format (UK/International)
    // Note: We have to make an assumption here since MM-DD-YYYY and DD-MM-YYYY use the same pattern
    // For medical applications in the US, we'll default to assuming MM-DD-YYYY when the pattern is ambiguous
    const hyphenDatePattern = /^(\d{1,2})-(\d{1,2})-(\d{4})$/;
    if (hyphenDatePattern.test(dateString)) {
      const [_, firstNum, secondNum, year] =
        hyphenDatePattern.exec(dateString) || [];

      // For medical records in the US, we'll assume MM-DD-YYYY format
      // If this needs to be configurable for international use, this could be parameterized
      const month = firstNum;
      const day = secondNum;

      const formattedDate = `${year}-${month.padStart(2, "0")}-${day.padStart(2, "0")}`;
      console.log(
        `[Patient Parser] Hyphen date format detected: ${dateString} → ${formattedDate}`,
      );
      console.log(
        `[Patient Parser] Assuming MM-DD-YYYY format for US medical records`,
      );
      return formattedDate;
    }

    // Format like "May 15, 1990" or "15 May 1990" or "December 18, 1933"
    const monthNames = [
      "january",
      "february",
      "march",
      "april",
      "may",
      "june",
      "july",
      "august",
      "september",
      "october",
      "november",
      "december",
    ];

    const lowerDateStr = dateString.toLowerCase();

    // Special handling for common formats like "Month DD, YYYY"
    const monthDayYearPattern = /([a-z]+)\s+(\d{1,2}),?\s+(\d{4})/i;
    const dayMonthYearPattern = /(\d{1,2})\s+([a-z]+)\s+(\d{4})/i;

    // Check for Month Day, Year format (e.g., "December 18, 1933")
    if (monthDayYearPattern.test(dateString)) {
      const matches = monthDayYearPattern.exec(dateString);
      if (matches) {
        const [_, monthText, dayText, yearText] = matches;
        const monthIndex = monthNames.findIndex((m) =>
          monthText.toLowerCase().includes(m.toLowerCase()),
        );

        if (monthIndex !== -1) {
          const month = String(monthIndex + 1).padStart(2, "0");
          const day = String(parseInt(dayText)).padStart(2, "0");
          const formattedDate = `${yearText}-${month}-${day}`;
          console.log(
            `[Patient Parser] Month-text formatted date (MDY): ${dateString} → ${formattedDate}`,
          );
          return formattedDate;
        }
      }
    }

    // Check for Day Month Year format (e.g., "18 December 1933")
    if (dayMonthYearPattern.test(dateString)) {
      const matches = dayMonthYearPattern.exec(dateString);
      if (matches) {
        const [_, dayText, monthText, yearText] = matches;
        const monthIndex = monthNames.findIndex((m) =>
          monthText.toLowerCase().includes(m.toLowerCase()),
        );

        if (monthIndex !== -1) {
          const month = String(monthIndex + 1).padStart(2, "0");
          const day = String(parseInt(dayText)).padStart(2, "0");
          const formattedDate = `${yearText}-${month}-${day}`;
          console.log(
            `[Patient Parser] Month-text formatted date (DMY): ${dateString} → ${formattedDate}`,
          );
          return formattedDate;
        }
      }
    }

    // Generic check for any text containing a month name
    for (let i = 0; i < monthNames.length; i++) {
      if (lowerDateStr.includes(monthNames[i])) {
        console.log(
          `[Patient Parser] Found month name '${monthNames[i]}' in date string`,
        );
        // Attempt to find numbers in the string that could be day and year
        const numbers = lowerDateStr.match(/\d+/g) || [];
        if (numbers.length >= 2) {
          // Assume the 4-digit number is the year, and the other is the day
          const yearCandidate = numbers.find((n) => n.length === 4);
          const dayCandidate = numbers.find((n) => n.length <= 2);

          if (yearCandidate && dayCandidate) {
            const month = String(i + 1).padStart(2, "0");
            const day = String(parseInt(dayCandidate)).padStart(2, "0");
            const formattedDate = `${yearCandidate}-${month}-${day}`;
            console.log(
              `[Patient Parser] Extracted date components from text: ${formattedDate}`,
            );
            return formattedDate;
          }
        }
      }
    }

    // General fallback - try to parse the date
    // Fix timezone issue by ensuring we're using UTC
    // This ensures dates don't shift due to timezone differences
    const dateStringWithTime = `${dateString}T12:00:00Z`;

    // Using UTC methods to avoid timezone issues
    const date = new Date(dateStringWithTime);

    // Debugging
    console.log(`[Patient Parser] Original date string: ${dateString}`);
    console.log(`[Patient Parser] Date with time: ${dateStringWithTime}`);
    console.log(`[Patient Parser] Parsed date object:`, date);

    // Check if date is valid
    if (isNaN(date.getTime())) {
      console.warn(`[Patient Parser] Could not parse date: ${dateString}`);
      return dateString; // Return original if invalid
    }

    // Format to YYYY-MM-DD using UTC values to prevent day shifting
    const year = date.getUTCFullYear();
    const month = String(date.getUTCMonth() + 1).padStart(2, "0");
    const day = String(date.getUTCDate()).padStart(2, "0");

    const formattedDate = `${year}-${month}-${day}`;
    console.log(`[Patient Parser] Formatted date: ${formattedDate}`);

    return formattedDate;
  } catch (e) {
    console.error(`[Patient Parser] Error formatting date: ${dateString}`, e);
    // If any error occurs, return the original
    return dateString;
  }
}
