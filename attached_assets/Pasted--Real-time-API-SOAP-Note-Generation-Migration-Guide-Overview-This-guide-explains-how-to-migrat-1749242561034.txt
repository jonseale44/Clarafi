# Real-time API SOAP Note Generation Migration Guide

## Overview

This guide explains how to migrate from standard GPT-4o Chat Completions API to OpenAI's Real-time API for SOAP note generation, based on the implementation in our current medical documentation platform.

## Architecture Decision

**Use Real-time API for:**
- SOAP note generation (streaming, immediate feedback)
- Live transcription during recording
- Real-time AI insights during patient encounters

**Keep Assistant API for:**
- GPT suggestions and recommendations
- Complex medical reasoning requiring context
- Patient history analysis

## Implementation Components

### 1. WebSocket Client Setup

Create a WebSocket client to handle Real-time API connections:

```typescript
// utils/WebSocketClient.ts
export class WebSocketClient {
  private ws: WebSocket | null = null;
  private apiKey: string;
  private eventHandler: WebSocketEventHandler | null = null;
  public transcriptionContent: string = "";

  constructor(
    apiKey: string,
    prompt: string,
    onMessage: (event: any) => void,
    patientChart?: any
  ) {
    this.apiKey = apiKey;
    this.eventHandler = new WebSocketEventHandler(this, onMessage, patientChart);
  }

  async init(): Promise<void> {
    const url = "wss://api.openai.com/v1/realtime?model=gpt-4o-realtime-preview-2024-10-01";
    
    this.ws = new WebSocket(url, [
      "realtime",
      `openai-insecure-api-key.${this.apiKey}`,
    ]);

    this.ws.onopen = this.handleOpen.bind(this);
    this.ws.onmessage = this.handleMessage.bind(this);
    this.ws.onclose = this.handleClose.bind(this);
    this.ws.onerror = this.handleError.bind(this);
  }

  public sendMessage(message: any): void {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(message));
    }
  }

  public requestSOAPNote(instructions: string): void {
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
      console.error("WebSocket not connected for SOAP note request");
      return;
    }

    const transcriptionText = this.transcriptionContent || "";
    
    const response = {
      type: "response.create",
      response: {
        modalities: ["text"],
        instructions: instructions,
        metadata: {
          type: "soap_note",
          partial_updates: "false",
        },
        max_output_tokens: 4096,
        input: [
          {
            type: "message",
            role: "system",
            content: [
              {
                type: "input_text",
                text: "Generate a SOAP note based on the provided transcription and instructions."
              },
            ],
          },
          {
            type: "message",
            role: "user",
            content: [
              {
                type: "input_text",
                text: `Instructions:\n${instructions}\n\nTranscription:\n${transcriptionText}`,
              },
            ],
          },
        ],
        temperature: 0.7,
      },
    };
    
    this.ws.send(JSON.stringify(response));
  }

  private handleMessage(event: MessageEvent): void {
    try {
      const data = JSON.parse(event.data);
      this.eventHandler?.handleEvent(data);
    } catch (error) {
      console.error("Error parsing WebSocket message:", error);
    }
  }
}
```

### 2. Event Handler for Real-time Responses

```typescript
// utils/WebSocketEventHandler.ts
export class WebSocketEventHandler {
  private webSocketClient: WebSocketClient;
  private onMessage: (event: any) => void;
  public soapNoteModule: SOAPNoteModule | null = null;
  public draftOrdersModule: DraftOrdersModule | null = null;

  constructor(
    webSocketClient: WebSocketClient,
    onMessage: (event: any) => void,
    patientChart?: any
  ) {
    this.webSocketClient = webSocketClient;
    this.onMessage = onMessage;
    
    // Initialize modules
    this.soapNoteModule = new SOAPNoteModule(
      webSocketClient.ws,
      () => this.handleReconnection()
    );
    
    this.draftOrdersModule = new DraftOrdersModule(webSocketClient.ws);
    
    if (patientChart) {
      this.soapNoteModule.setPatientChart(patientChart);
      this.draftOrdersModule.setPatientChart(patientChart);
    }
  }

  handleEvent(data: any): void {
    switch (data.type) {
      case "response.text.delta":
        if (data.response?.metadata?.type === "soap_note") {
          this.handleSOAPNoteDelta(data);
        }
        break;
        
      case "response.text.done":
        if (data.response?.metadata?.type === "soap_note") {
          this.handleSOAPNoteCompletion(data);
        }
        break;
        
      case "response.done":
        if (data.response?.metadata?.type === "draft_orders") {
          this.handleDraftOrdersCompletion(data);
        }
        break;
    }
  }

  private handleSOAPNoteDelta(data: any): void {
    const delta = data.delta || "";
    this.onMessage({
      type: "soap.note.delta",
      delta: delta,
    });
  }

  private handleSOAPNoteCompletion(data: any): void {
    const event = this.soapNoteModule?.handleGptResponse(data);
    if (event) {
      this.onMessage(event);
    }
  }
}
```

### 3. SOAP Note Module

```typescript
// utils/modules/SOAPNoteModule.ts
export class SOAPNoteModule {
  private patientChart: any = null;
  private ws: WebSocket | null = null;
  private isCompleted: boolean = false;

  constructor(webSocket: WebSocket | null, onReconnectNeeded?: () => void) {
    this.initializeWebSocket(webSocket);
  }

  setPatientChart(chart: any): void {
    if (!chart?.patient_id) {
      console.error("Invalid patient chart - missing patient_id");
      return;
    }
    this.patientChart = chart;
  }

  handleGptResponse(data: any): any {
    if (data.type === "response.text.done") {
      const fullText = data.response?.text || "";
      
      if (!fullText.trim()) {
        console.warn("Empty SOAP note received from GPT");
        return null;
      }

      this.isCompleted = true;
      
      // Trigger draft orders generation after SOAP completion
      if (this.patientChart?.patient_id) {
        setTimeout(() => {
          this.triggerDraftOrders(fullText);
        }, 0);
      }

      return {
        type: "soap.note.completed",
        note: fullText,
      };
    }
    return null;
  }

  private triggerDraftOrders(soapNote: string): void {
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
      console.error("WebSocket not ready for draft orders");
      return;
    }

    const draftOrderInstructions = `
Extract medication, lab, and imaging orders from this SOAP note.

For medications, format as follows:
Medication: [name and dosage]
Sig: [instructions]
Dispense: [quantity] tablets
Refills: [number]

For labs, format as follows:
Lab: [test name]

For imaging, format as follows:
Imaging: [modality and body part]
Instructions: [any special instructions]
Priority: [routine/stat]

Each order must be separated by two newlines.
`;

    const message = {
      type: "response.create",
      response: {
        conversation: "none",
        modalities: ["text"],
        instructions: draftOrderInstructions,
        metadata: { type: "draft_orders" },
        max_output_tokens: 2048,
        input: [
          {
            type: "message",
            role: "user",
            content: [{ type: "input_text", text: soapNote }],
          },
        ],
        temperature: 0.7,
      },
    };

    this.ws.send(JSON.stringify(message));
  }
}
```

### 4. SOAP Note Instructions Template

```typescript
// Constants for SOAP note generation
const SOAP_INSTRUCTIONS = `
Generate a SOAP note with the following sections, each preceded by FOUR blank lines:

(preceded by FOUR blank lines)**SUBJECTIVE:**
Summarize patient-reported symptoms, concerns, relevant history, and review of systems. Use bullet points for clarity. 

(preceded by FOUR blank lines)**OBJECTIVE:** Organize this section as follows:

Vitals: List all vital signs in a single line, formatted as:
BP: [value] | HR: [value] | Temp: [value] | RR: [value] | SpO2: [value]

PHYSICAL EXAM:
- If the physical exam is completely **normal**, use the following full, pre-defined template verbatim:

Physical Exam:
Gen: AAO x 3. NAD.
HEENT: MMM, no lymphadenopathy.
CV: Normal rate, regular rhythm. No m/c/g/r.
Lungs: Normal work of breathing. CTAB.
Abd: Normoactive bowel sounds. Soft, non-tender.
Ext: No clubbing, cyanosis, or edema.
Skin: No rashes or lesions.

Modify only abnormal systems. All normal areas must remain unchanged.

Do NOT use diagnostic terms. Write only objective physician-level findings.

Labs: List any lab results if available. If none, state "No labs reported today."

(preceded by FOUR blank lines)**ASSESSMENT/PLAN:**
[Condition (ICD-10 Code)]: Provide a concise, bullet-pointed plan for the condition.

(preceded by FOUR blank lines)**ORDERS:** 
For all orders, follow this highly-structured format:

Medications:
Each medication order must follow this exact template:
Medication: [name, include specific formulation and strength]
Sig: [detailed instructions for use]
Dispense: [quantity]
Refills: [number of refills allowed]

Labs: List specific tests ONLY. Be concise (e.g., "CBC, BMP, TSH").

Imaging: Specify the modality and purpose in clear terms.

Referrals: Clearly indicate the specialty and purpose of the referral.

CPT Codes: Include relevant CPT codes in JSON format:
{
  "metadata": {
    "type": "cpt_codes"
  },
  "content": [
    {
      "code": "[CPT CODE]",
      "description": "[PROCEDURE DESCRIPTION]",
      "complexity": "low|medium|high"
    }
  ]
}

Use clear headers to distinguish sections.
Precede each section header with four blank lines.
Include ICD-10 codes for all conditions immediately after each condition in the Assessment/Plan section.
`;
```

### 5. Component Integration

```typescript
// components/SOAPNoteGenerator.tsx
export const SOAPNoteGenerator: React.FC<{
  patientId: string;
  encounterId: string;
  transcription: string;
}> = ({ patientId, encounterId, transcription }) => {
  const [webSocketClient, setWebSocketClient] = useState<WebSocketClient | null>(null);
  const [soapNote, setSoapNote] = useState<string>("");
  const [isGenerating, setIsGenerating] = useState(false);

  const handleWebSocketMessage = (event: any) => {
    switch (event.type) {
      case "soap.note.delta":
        setSoapNote(prev => prev + event.delta);
        break;
        
      case "soap.note.completed":
        setIsGenerating(false);
        // Trigger CPT code processing and draft orders
        break;
    }
  };

  const generateSOAPNote = async () => {
    if (!webSocketClient || !transcription) return;

    try {
      setIsGenerating(true);
      setSoapNote("");

      // Fetch patient chart
      const response = await fetch(`/api/patients/${patientId}/chart`);
      const patientChart = await response.json();
      
      const enrichedChart = {
        ...patientChart,
        patient_id: parseInt(patientId),
        id: parseInt(patientId),
      };

      // Set patient chart in modules
      if (webSocketClient.eventHandler?.soapNoteModule) {
        webSocketClient.eventHandler.soapNoteModule.setPatientChart(enrichedChart);
      }

      // Update transcription content
      webSocketClient.updateTranscriptionContent(transcription);

      // Request SOAP note generation
      webSocketClient.requestSOAPNote(SOAP_INSTRUCTIONS);

    } catch (error) {
      console.error("Error generating SOAP note:", error);
      setIsGenerating(false);
    }
  };

  const handleStopRecording = async () => {
    if (webSocketClient && transcription) {
      await generateSOAPNote();
    }
  };

  return (
    <div>
      <Button onClick={handleStopRecording} disabled={isGenerating}>
        {isGenerating ? "Generating..." : "Stop and Generate SOAP Note"}
      </Button>
      
      <div className="soap-note-editor">
        {soapNote}
      </div>
    </div>
  );
};
```

### 6. Migration Steps

1. **Install WebSocket Dependencies:**
   ```bash
   npm install ws @types/ws
   ```

2. **Replace Standard API Calls:**
   - Remove `openai.chat.completions.create()` calls for SOAP generation
   - Replace with WebSocket-based Real-time API calls

3. **Environment Variables:**
   ```env
   VITE_OPENAI_API_KEY=your_openai_api_key
   ```

4. **Update Request Parameters:**
   ```typescript
   // OLD: Standard API
   const completion = await openai.chat.completions.create({
     model: "gpt-4.1-nano",
     messages: [{ role: "user", content: prompt }],
     temperature: 0.7,
     max_tokens: 4096,
   });

   // NEW: Real-time API
   const responsePayload = {
     type: "response.create",
     response: {
       modalities: ["text"],
       instructions: SOAP_INSTRUCTIONS,
       metadata: { type: "soap_note" },
       max_output_tokens: 4096,
       temperature: 0.7,
       input: [
         {
           type: "message",
           role: "user",
           content: [{ type: "input_text", text: transcription }],
         }
       ],
     },
   };
   ```

### 7. Keep Assistant API for GPT Suggestions

```typescript
// services/assistantService.ts - Keep this for suggestions
export class AssistantService {
  async generateSuggestions(patientId: number, context: string): Promise<string[]> {
    // Continue using Assistant API for complex reasoning
    const assistantId = await this.getMedicalAssistant();
    const threadId = await this.getPatientThread(patientId);
    
    const response = await openai.beta.threads.runs.create(threadId, {
      assistant_id: assistantId,
      instructions: "Provide medical suggestions based on patient context"
    });
    
    return this.extractSuggestions(response);
  }
}
```

## Performance Benefits

- **Streaming Response:** Users see content appearing in real-time (~2-3 seconds to start)
- **Lower Latency:** WebSocket eliminates HTTP request overhead
- **Better UX:** Immediate feedback vs. waiting for complete response
- **Faster Generation:** Real-time API optimized for interactive use cases

## Error Handling

```typescript
private handleWebSocketError(error: Event): void {
  console.error("WebSocket error:", error);
  // Implement reconnection logic
  this.reconnectWebSocket();
}

private async reconnectWebSocket(): Promise<void> {
  await new Promise(resolve => setTimeout(resolve, 1000));
  await this.init();
}
```

This migration will provide significantly faster SOAP note generation while maintaining the quality and accuracy of your medical documentation system.