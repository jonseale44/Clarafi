import { WebSocketEventHandler } from "./WebSocketEventHandler";
import { connectionMonitor } from "./ConnectionMonitor";

/**
 * API endpoints for OpenAI's Realtime service
 */
const API_URL = "https://api.openai.com/v1/realtime/sessions";
const WEBSOCKET_URL = "wss://api.openai.com/v1/realtime";

/**
 * WebSocketClient handles real-time communication with OpenAI's API
 * Features:
 * - Session management with automatic token refresh
 * - Audio streaming and processing
 * - Event handling through WebSocketEventHandler
 * - Logging system for debugging
 */
export class WebSocketClient {
  private ws: WebSocket | null = null;
  private sessionToken: string | null = null;
  private sessionId: string | null = null;
  private clientSecretExpiresAt: number | null = null;
  private isReady: boolean = false;
  private onReadyCallback: (() => void) | null = null;
  public eventHandler!: WebSocketEventHandler; // Using the definite assignment assertion and making it public
  private logs: string[] = [];

  /**
   * @param apiKey - OpenAI API key for authentication
   * @param prompt - System instructions for the AI model
   * @param onMessage - Callback for handling incoming messages
   */
  private apiKey: string = '';
  private prompt: string = '';
  private onMessage: (event: any) => void = () => {};
  private patientChart: any;
  private sentPatientCharts: Set<string> = new Set(); // Track which patient charts have been sent
  
  // Support for NurseTranscription style config
  private patientId?: number;
  private encounterId?: string;
  private onTranscriptUpdate?: (text: string) => void;
  private onGPTUpdate?: (text: string) => void;

  constructor(apiKeyOrConfig: string | any, prompt?: string, onMessage?: (event: any) => void, patientChart?: any) {
    // Support both initialization styles:
    // 1. MainTranscription style: (apiKey, prompt, onMessage, patientChart?)
    // 2. NurseTranscription style: ({ patientId, encounterId, onTranscriptUpdate, onGPTUpdate })
    
    console.log("[WebSocketClient] Constructor called");
    
    // Enhanced logging for API key handling
    if (typeof apiKeyOrConfig === 'object') {
      console.log("[WebSocketClient] Initializing with config object");
      console.log("[WebSocketClient] Config contains patientId:", !!apiKeyOrConfig.patientId);
      console.log("[WebSocketClient] Config contains encounterId:", !!apiKeyOrConfig.encounterId);
      console.log("[WebSocketClient] Config contains API key:", !!apiKeyOrConfig.apiKey);
      console.log("[WebSocketClient] Has transcript update handler:", !!apiKeyOrConfig.onTranscriptUpdate);
      console.log("[WebSocketClient] Has GPT update handler:", !!apiKeyOrConfig.onGPTUpdate);
    } else {
      console.log("[WebSocketClient] Initializing with direct parameters");
      console.log("[WebSocketClient] Has API key:", !!apiKeyOrConfig);
      console.log("[WebSocketClient] Has prompt:", !!prompt);
      console.log("[WebSocketClient] Has message handler:", !!onMessage);
      console.log("[WebSocketClient] Has patient chart:", !!patientChart);
    }
    
    if (typeof apiKeyOrConfig === 'string') {
      // MainTranscription style initialization
      console.log("[WebSocketClient] Using string-style initialization");
      this.apiKey = apiKeyOrConfig;
      this.prompt = prompt || '';
      this.onMessage = onMessage || (() => {});
      this.patientChart = patientChart;
    } else {
      // NurseTranscription style initialization (object config)
      console.log("[WebSocketClient] Using object-style initialization");
      
      // First check if apiKey is provided in the config object
      if (apiKeyOrConfig.apiKey) {
        console.log("[WebSocketClient] Using API key from config object");
        this.apiKey = apiKeyOrConfig.apiKey;
      } else {
        // Fallback to environment variable if API key not in config
        // In browser, environment vars must be prefixed with VITE_
        console.log("[WebSocketClient] Falling back to environment variable for API key");
        this.apiKey = import.meta.env.VITE_OPENAI_API_KEY || '';
      }
      
      // Check if a custom prompt is provided in the config object
      if (apiKeyOrConfig.prompt) {
        console.log("[WebSocketClient] Using custom prompt from config object");
        this.prompt = apiKeyOrConfig.prompt;
      } else {
        // Use default prompt if none provided
        console.log("[WebSocketClient] Using default prompt");
        this.prompt = 'You are a helpful medical assistant trained to assist with medical documentation. You will analyze patient encounters and provide structured medical notes.';
      }
      
      // Store NurseTranscription specific properties
      this.patientId = apiKeyOrConfig.patientId;
      this.encounterId = apiKeyOrConfig.encounterId;
      this.onTranscriptUpdate = apiKeyOrConfig.onTranscriptUpdate;
      this.onGPTUpdate = apiKeyOrConfig.onGPTUpdate;
      
      // Create a wrapper message handler that routes to the correct callbacks
      this.onMessage = (event: any) => {
        // Handle all the different transcript event types
        if (event.type === 'response.transcript' || 
            event.type === 'transcription.delta' || 
            event.type === 'transcription.completed' ||
            event.type === 'conversation.item.input_audio_transcription.delta' ||
            event.type === 'conversation.item.input_audio_transcription.completed') {
          
          // Extract the transcript content from various event formats
          const transcriptContent = event.transcript || event.delta?.text || event.delta || '';
          
          // Log detailed debug information
          console.log(`[WebSocketClient] Received transcript event: ${event.type}`, transcriptContent.substring(0, 30) + '...');
          
          // Send to callback if available
          if (this.onTranscriptUpdate) {
            console.log('[WebSocketClient] Calling onTranscriptUpdate callback');
            this.onTranscriptUpdate(transcriptContent);
          } else {
            console.warn('[WebSocketClient] No onTranscriptUpdate callback available');
          }
        } 
        // Handle all GPT analysis event types but check if it's not a SOAP note
        else if ((event.type === 'response.text' || event.type === 'gpt.analysis.delta') && 
                 !(event.metadata?.type === 'soap_note' || event.response?.metadata?.type === 'soap_note')) {
          
          // Extract the text content
          const textContent = event.text || event.delta || '';
          
          // Log detailed debug information
          console.log(`[WebSocketClient] Received GPT event: ${event.type}`, textContent.substring(0, 30) + '...');
          
          // Send to callback if available
          if (this.onGPTUpdate) {
            console.log('[WebSocketClient] Calling onGPTUpdate callback');
            this.onGPTUpdate(textContent);
          } else {
            console.warn('[WebSocketClient] No onGPTUpdate callback available');
          }
        }
        // Handle SOAP note events from both direct soap.note events and response.text with soap_note metadata
        else if (event.type === 'soap.note.delta' || 
                 event.type === 'soap.note.completed' || 
                 (event.type === 'response.text' && (event.metadata?.type === 'soap_note' || event.response?.metadata?.type === 'soap_note'))) {
          console.log(`[WebSocketClient] Received SOAP note event: ${event.type}`);
          
          // If it's a response.text event with soap_note metadata, transform it into a soap.note event
          let transformedEvent = event;
          if (event.type === 'response.text') {
            if (event.response?.status === "done") {
              // For completed responses, convert to soap.note.completed
              transformedEvent = {
                type: "soap.note.completed",
                note: event.text || ""
              };
              console.log('[WebSocketClient] Transformed response.text to soap.note.completed');
            } else {
              // For deltas, convert to soap.note.delta
              transformedEvent = {
                type: "soap.note.delta",
                delta: event.delta || event.text || ""
              };
              console.log('[WebSocketClient] Transformed response.text to soap.note.delta');
            }
          }
          
          // Forward to the configured callback
          if (apiKeyOrConfig.onMessage) {
            console.log('[WebSocketClient] Forwarding SOAP note event to onMessage callback');
            apiKeyOrConfig.onMessage(transformedEvent);
          } else {
            console.warn('[WebSocketClient] No onMessage callback available for SOAP note event');
          }
        }
      };
      
      // Create patientChart object from patientId
      if (this.patientId) {
        this.patientChart = { patient_id: this.patientId, id: this.patientId };
      }
    }
    
    // Start connection monitoring
    connectionMonitor.startMonitoring();
  }

  /**
   * Returns concatenated logs for debugging
   */
  public getAllLogs(): string {
    return this.logs.join("\n");
  }
  
  /**
   * Check if the client has a valid API key
   * Used by components to validate before attempting operations
   */
  public hasValidApiKey(): boolean {
    // Check if we have a non-empty API key
    const hasKey = !!this.apiKey && this.apiKey.length > 0;
    console.log("[WebSocketClient] API key validity check:", hasKey ? "Present" : "Missing");
    return hasKey;
  }
  
  /**
   * Check if client has been initialized
   * Used by components to determine if init() needs to be called
   */
  public isInitialized(): boolean {
    // Check if we have a session ID and token
    const initialized = !!this.sessionId && !!this.sessionToken;
    console.log("[WebSocketClient] Initialization status:", initialized ? "Initialized" : "Not initialized");
    return initialized;
  }

  /**
   * Sends a message through the WebSocket connection
   * Includes error handling for connection state
   */
  public sendMessage(data: any) {
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
      console.error(
        "[WebSocket] Cannot send message: WebSocket not connected.",
      );
      return;
    }

    // Import dynamically to avoid circular dependencies
    import("./Logger").then(({ Logger }) => {
      // Comprehensive logging of outgoing data
      Logger.logOutgoingData(data);
    });

    //commenting this out results in nothing working
    console.log("[WebSocket] Sending message:", data);
    this.ws.send(JSON.stringify(data));
  }

  /**
   * Initializes the WebSocket session with OpenAI
   * Features:
   * - Sets up audio transcription with Whisper
   * - Configures turn detection for conversation flow
   * - Handles session token management
   */
  async init() {
    console.log("[WebSocketClient] Initializing with API key:", this.apiKey ? "Present (masked)" : "Missing");
    
    // Check API key from environment and current instance
    const envApiKey = import.meta.env.VITE_OPENAI_API_KEY;
    console.log("[WebSocketClient] Environment API key check:", envApiKey ? "Present in env" : "Missing from env");
    console.log("[WebSocketClient] Instance API key length:", this.apiKey?.length || 0);
    
    // Try to fetch API key from server if not available
    if (!this.apiKey) {
      console.log("[WebSocketClient] Attempting to fetch API key status from server");
      try {
        const response = await fetch('/api/openai-key-check');
        const data = await response.json();
        console.log("[WebSocketClient] Server API key status:", data);
        
        if (data.available) {
          console.log("[WebSocketClient] Server reports API key is available, but client doesn't have access");
          console.log("[WebSocketClient] This suggests an environment configuration issue");
        }
      } catch (error) {
        console.error("[WebSocketClient] Failed to check API key status from server:", error);
      }
      
      console.error("[WebSocketClient] No API key available. Cannot initialize session.");
      throw new Error("API key is required for WebSocket initialization");
    }
    
    try {
      // Session configuration for real-time AI interaction
      const sessionConfig = {
        model: "gpt-4o-mini-realtime-preview-2024-12-17",
        modalities: ["text"],
        instructions: this.prompt,
        input_audio_format: "pcm16",
        input_audio_transcription: {
          model: "whisper-1",
          language: "en",
          prompt:
            "You MUST ALWAYS translate the speech into English ONLY, regardless of input language. NEVER include the original non-English text. ONLY OUTPUT ENGLISH text. Translate all utterances, questions, and statements fully to English without leaving any words in the original language.",
        },
        turn_detection: {
          type: "server_vad",
          threshold: 0.5,
          prefix_padding_ms: 300,
          silence_duration_ms: 500,
          create_response: true,
        },

        tools: [],
        tool_choice: "none",
        temperature: 1,
        max_response_output_tokens: "inf",
      };

      console.log("[Session Config Sent]:", sessionConfig);

      // Create session with OpenAI
      const response = await fetch(API_URL, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${this.apiKey}`,
          "OpenAI-Beta": "realtime=v1",
        },
        body: JSON.stringify(sessionConfig),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(
          `Failed to create session: ${error.message || "Unknown error"}`,
        );
      }

      const session = await response.json();
      console.log("[Session Response Received]:", session);

      // Validate session configuration
      if (!session.input_audio_transcription) {
        console.error("[Whisper Transcription] Not enabled in session!");
      }
      if (!session.client_secret?.value || !session.id) {
        throw new Error("Invalid session response");
      }

      // Store session details
      this.sessionToken = session.client_secret.value;
      this.sessionId = session.id;
      this.clientSecretExpiresAt = session.client_secret.expires_at;

      const logMsg = `[Session] Created with ID: ${this.sessionId}`;
      console.log(logMsg);
      this.logs.push(logMsg);

      await this.connect();
    } catch (error: any) {
      const errorMessage = error.message || "Unknown error occurred";
      console.error("[Session] Error:", {
        message: errorMessage,
        status: error.status,
        response: error.response,
      });
      throw new Error(`Session initialization failed: ${errorMessage}`);
    }
  }

  /**
   * Establishes WebSocket connection with OpenAI
   * Features:
   * - Protocol negotiation
   * - Session state management
   * - Event handling setup
   */
  private async connect() {
    if (!this.sessionToken || !this.sessionId) {
      console.error("[WebSocket] Cannot connect: Missing session details");
      return;
    }

    try {
      const protocols = [
        "realtime",
        `openai-insecure-api-key.${this.apiKey}`,
        // Beta protocol, required
        "openai-beta.realtime-v1",
      ];

      const params = new URLSearchParams({
        model: "gpt-4o-mini-realtime-preview-2024-12-17",
      });

      // Add required beta header
      const headers = {
        "OpenAI-Beta": "realtime=v1",
      };

      console.log("[WebSocket] Session ID:", this.sessionId);
      console.log("[WebSocket] Connecting with protocols:", protocols);

      this.ws = new WebSocket(
        `${WEBSOCKET_URL}?${params.toString()}`,
        protocols,
      );

      // Connection established handler
      this.ws.onopen = () => {
        this.eventHandler = new WebSocketEventHandler(this.ws, this.onMessage);
        console.log("[WebSocket] Connected successfully");
        this.isReady = true;

        // Update session configuration
        this.sendMessage({
          type: "session.update",
          session: {
            instructions: this.prompt,
            model: "gpt-4o-mini-realtime-preview-2024-12-17",
            modalities: ["text"], // Keep audio modality for input
            // output_modalities: ["text"], // Explicitly specify text-only output
            input_audio_format: "pcm16", // Still needed for audio input
            input_audio_transcription: {
              model: "whisper-1",
              language: "en",
              prompt:
                "You MUST ALWAYS translate the speech into English ONLY, regardless of input language. NEVER include the original non-English text. ONLY OUTPUT ENGLISH text. Translate all utterances, questions, and statements fully to English without leaving any words in the original language.",
            },
            turn_detection: {
              type: "server_vad",
              threshold: 0.3, // Lower threshold for better sensitivity
              prefix_padding_ms: 500, // Increased to catch more of the start of speech
              silence_duration_ms: 1000, // Increased to allow for natural pauses
              create_response: true,
            },
          },
        });

        if (this.onReadyCallback) {
          this.onReadyCallback();
        }
      };

      // Message handler
      this.ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          this.handleWebSocketMessage(data); // Use the updated message handler
        } catch (error) {
          console.error("[WebSocket] Error parsing message:", error);
        }
      };

      // Connection close handler
      this.ws.onclose = (event) => {
        console.warn(
          `[WebSocket] Disconnected. Code: ${event.code}, Reason: ${event.reason}`,
        );
      };

      // Error handler
      this.ws.onerror = (error) => {
        console.error("[WebSocket] Error occurred:", error);
      };
    } catch (error) {
      console.error("[WebSocket] Connection error:", error);
    }
  }

  /**
   * Validates and refreshes session token if expired
   */
  private async validateToken() {
    const now = Math.floor(Date.now() / 1000);
    if (this.clientSecretExpiresAt && this.clientSecretExpiresAt <= now) {
      console.warn("[WebSocket] Token expired, creating new session...");
      try {
        await this.init();
        return true;
      } catch (error) {
        console.error("[WebSocket] Failed to renew session:", error);
        // Attempt to reconnect after a delay
        setTimeout(() => this.init(), 5000);
        return false;
      }
    }
    return false;
  }

  /**
   * Processes and sends audio data to OpenAI
   * Features:
   * - Audio blob to base64 conversion
   * - Automatic token validation
   * - Error handling
   */
  public async appendAudio(audioBlob: Blob) {
    await this.validateToken();
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
      console.error("WebSocket not connected");
      return;
    }

    const reader = new FileReader();
    reader.onload = () => {
      try {
        // Convert audio to base64 format
        const arrayBuffer = reader.result as ArrayBuffer;
        const uint8Array = new Uint8Array(arrayBuffer);
        let binary = "";
        for (let i = 0; i < uint8Array.length; i++) {
          binary += String.fromCharCode(uint8Array[i]);
        }
        const base64Audio = btoa(binary);

        // Send audio buffer
        this.sendMessage({
          type: "input_audio_buffer.append",
          audio: base64Audio,
        });
        console.log(
          "[WebSocket] Sent audio buffer:",
          base64Audio.length,
          "bytes",
        );
      } catch (error) {
        console.error("[WebSocket] Error processing audio:", error);
      }
    };
    reader.readAsArrayBuffer(audioBlob);
  }

  /**
   * Registers callback for connection ready state
   */
  public onReady(callback: () => void) {
    if (this.isReady) {
      callback();
    } else {
      this.onReadyCallback = callback;
    }
  }


  /**
   * Safely closes the WebSocket connection
   * Handles any errors that might occur during close
   */
  public close() {
    try {
      if (this.ws) {
        if (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING) {
          console.log("[WebSocketClient] Closing WebSocket connection");
          this.ws.close();
        } else {
          console.log("[WebSocketClient] WebSocket already closed or closing");
        }
        // Clear the reference
        this.ws = null;
      }
      this.isReady = false;
    } catch (error) {
      console.error("[WebSocketClient] Error while closing WebSocket:", error);
    }
    this.sessionToken = null;
    this.sessionId = null;
    this.isReady = false;
    this.resetPatientChartCache(); // Reset cache when closing
  }

  private lastTokenTrackTime = 0;
  private tokenTrackThrottle = 1000; // 1000ms (1 second) throttle for token tracking

  private handleWebSocketMessage = (event: any) => {
    // Track tokens only for specific event types to avoid duplicates
    if (event.response?.usage && event.type === "response.done") {
      const now = Date.now();

      // Only track tokens if more than 250ms have passed since the last tracking
      // and avoid tracking duplicate events for the same conversation
      if (now - this.lastTokenTrackTime >= this.tokenTrackThrottle) {
        this.lastTokenTrackTime = now;
        const usage = event.response.usage;
        this.saveTokenUsage({
          input_tokens: usage.input_tokens || 0,
          output_tokens: usage.output_tokens || 0,
          total_tokens: usage.total_tokens || 0,
          source: event.type, // Track which service generated the tokens
          metadata: event.response?.metadata || {},
        });
      }
    }

    if (this.eventHandler) {
      this.eventHandler.handleEvent(event);
    }
  };

  private async saveTokenUsage(usage: any) {
    if (!this.patientChart?.patient_id) {
      console.warn(
        "[WebSocketClient] Cannot save token usage: Missing patient_id",
      );
      return;
    }

    // Validate token usage data
    if (!usage.input_tokens && !usage.output_tokens) {
      console.warn(
        `[WebSocketClient] Missing token usage data for source: ${usage.source}`,
      );
      return;
    }

    // Determine operation type based on source, metadata, and event context
    let operationType = "other";
    const source = (usage.source || "").toLowerCase();
    const metadata = (usage.metadata?.type || "").toLowerCase();

    // Prioritize metadata.type for categorization, fall back to source
    if (metadata === "soap_note" || source.includes("soap")) {
      operationType = "soap_note";
    } else if (metadata === "suggestions" || source.includes("analysis")) {
      operationType = "suggestions";
    } else if (
      metadata === "transcription" ||
      source.includes("audio_transcript") ||
      source.includes("transcription")
    ) {
      operationType = "transcription";
    }

    // Debug metadata handling
    console.log("[WebSocketClient] Token usage metadata:", {
      source,
      metadata,
      operationType,
      hasMetadata: !!metadata,
    });

    // Add debug logging
    console.log("[WebSocketClient] Token categorization:", {
      source,
      metadata,
      operationType,
      inputTokens: usage.input_tokens,
      outputTokens: usage.output_tokens,
    });

    // Log categorization details for debugging
    console.log("[WebSocketClient] Token usage detection:", {
      source,
      metadata,
      operationType,
      inputTokens: usage.input_tokens,
      outputTokens: usage.output_tokens,
    });

    console.log("[WebSocketClient] Token usage categorization:", {
      source: usage.source,
      operationType,
      inputTokens: usage.input_tokens,
      outputTokens: usage.output_tokens,
      totalTokens: usage.total_tokens,
    });

    console.log("[WebSocketClient] Token usage categorized:", {
      source: usage.source,
      operationType,
      tokens: usage.total_tokens,
    });

    console.log("[WebSocketClient] Tracking tokens:", {
      source: usage.source,
      tokens: usage.total_tokens,
      patientId: this.patientChart.patient_id,
      usage,
    });

    try {
      // Save token usage directly without creating an office visit
      const tokenResponse = await fetch("/api/token-usage", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          patient_id: parseInt(this.patientChart.patient_id),
          input_tokens: usage.input_tokens || 0,
          output_tokens: usage.output_tokens || 0,
          total_tokens: usage.total_tokens || 0,
          operation_type: operationType,
        }),
      });

      if (!tokenResponse.ok) {
        throw new Error("Failed to save token usage");
      }
      // Log token usage breakdown
      console.log("[WebSocketClient] Token usage:", {
        inputTokens: usage.input_tokens,
        outputTokens: usage.output_tokens,
        source: usage.source,
      });
    } catch (error) {
      console.error("Failed to save token usage:", error);
    }
  }

  hasPatientChartBeenSent(patientId: string | number): boolean {
    // Convert to string to ensure consistent handling
    const patientIdStr = patientId.toString();
    return this.sentPatientCharts.has(patientIdStr);
  }

  markPatientChartAsSent(patientId: string | number): void {
    // Convert to string to ensure consistent handling
    const patientIdStr = patientId.toString();
    this.sentPatientCharts.add(patientIdStr);
    console.log(`[WebSocketClient] Patient chart ${patientIdStr} marked as sent`);
  }

  resetPatientChartCache(): void {
    this.sentPatientCharts.clear();
    console.log(`[WebSocketClient] Patient chart cache cleared`);
  }

  // Store the current transcription text
  private transcriptionContent: string = "";

  /**
   * Updates the current transcription content for use in SOAP note generation
   * @param text The transcription text
   */
  public updateTranscriptionContent(text: string): void {
    this.transcriptionContent = text;
  }

  /**
   * Sends a request to generate a SOAP note based on instructions
   * @param instructions The instructions for generating the SOAP note
   */
  public requestSOAPNote(instructions: string): void {
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
      console.error("[WebSocket] Cannot send SOAP note request: WebSocket not connected.");
      return;
    }

    if (!this.eventHandler) {
      console.error("[WebSocket] Cannot generate SOAP note: Missing EventHandler");
      return;
    }

    // Get the most recent transcription
    const transcriptionText = this.transcriptionContent || "";
    
    // Create a response.create message with SOAP note metadata like SOAPNoteModule does
    const response = {
      type: "response.create",
      response: {
        modalities: ["text"],
        instructions: instructions,
        metadata: {
          type: "soap_note",
          partial_updates: "false", // Changed from boolean to string to fix API error
        },
        max_output_tokens: 2000,
        input: [
          {
            type: "message",
            role: "system",
            content: [
              {
                type: "input_text",
                text: "Generate a SOAP note based on the provided transcription and instructions."
              },
            ],
          },
          {
            type: "message",
            role: "user",
            content: [
              {
                type: "input_text",
                text: `Instructions:\n${instructions}\n\nTranscription:\n${transcriptionText}`,
              },
            ],
          },
        ],
        temperature: 0.7,
      },
    };
    
    console.log("[WebSocket] Sending SOAP note request");
    this.ws.send(JSON.stringify(response));
  }
}
