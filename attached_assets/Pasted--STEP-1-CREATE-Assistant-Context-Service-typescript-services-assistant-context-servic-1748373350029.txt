---

## STEP 1: CREATE Assistant Context Service

```typescript
// services/assistant-context-service.ts
import OpenAI from 'openai';

export class AssistantContextService {
  private openai: OpenAI;
  private assistantId: string;
  
  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
    });
    this.assistantId = process.env.OPENAI_ASSISTANT_ID || '';
  }
  
  async initializeAssistant() {
    if (!this.assistantId) {
      const assistant = await this.openai.beta.assistants.create({
        name: "Medical Context Assistant",
        instructions: `You are a medical AI assistant that provides real-time clinical decision support.

REAL-TIME SUGGESTIONS MODE:
When receiving partial transcriptions, provide immediate clinical suggestions:
- For NURSES: Assessment questions, symptom clarification, patient education
- For PROVIDERS: Differential diagnosis, treatment considerations, clinical red flags

HISTORICAL CONTEXT MODE:
Analyze patient history and provide contextual insights:
- Previous encounters and outcomes
- Recurring patterns and chronic conditions
- Relevant test results and medication responses
- Clinical decision continuity

OUTPUT FORMATS:
For real-time suggestions: 
{
  "suggestions": ["immediate suggestion 1", "immediate suggestion 2"],
  "clinicalFlags": ["urgent consideration if applicable"],
  "historicalContext": "relevant past encounter info"
}

For complete processing:
{
  "soapNote": { "subjective": "", "objective": "", "assessment": "", "plan": "" },
  "draftOrders": [{"type": "lab", "details": "CBC with diff", "indication": "anemia workup"}],
  "cptCodes": [{"code": "99213", "description": "Office visit", "units": 1}],
  "chartUpdates": { "historicalUpdates": {}, "factualAppends": {} }
}`,
        model: "gpt-4o",
        tools: []
      });
      this.assistantId = assistant.id;
    }
  }
  
  async getOrCreateThread(patientId: number): Promise<string> {
    // Check if patient already has thread in your new schema
    const patient = await db.select().from(patients)
      .where(eq(patients.id, patientId)).limit(1);
    
    if (patient[0]?.assistantThreadId) {
      return patient[0].assistantThreadId;
    }
    
    // Create new thread with patient context
    const thread = await this.openai.beta.threads.create();
    
    // Load patient's complete medical history
    const patientHistory = await this.getPatientHistory(patientId);
    
    // Add historical context to thread
    await this.openai.beta.threads.messages.create(thread.id, {
      role: "user",
      content: `Patient Historical Context: ${JSON.stringify(patientHistory)}`
    });
    
    // Save thread ID to patient record
    await db.update(patients)
      .set({ assistantThreadId: thread.id })
      .where(eq(patients.id, patientId));
    
    return thread.id;
  }
  
  // Real-time suggestions during transcription
  async getRealtimeSuggestions(
    threadId: string,
    partialTranscription: string,
    userRole: string,
    patientId: number
  ) {
    await this.openai.beta.threads.messages.create(threadId, {
      role: "user",
      content: `PARTIAL TRANSCRIPTION: "${partialTranscription}"
USER ROLE: ${userRole}
MODE: REAL_TIME_SUGGESTIONS

Provide immediate clinical suggestions based on this partial transcription.`
    });
    
    const run = await this.openai.beta.threads.runs.create(threadId, {
      assistant_id: this.assistantId
    });
    
    // Wait for completion (should be fast for suggestions)
    let runStatus = await this.openai.beta.threads.runs.retrieve(threadId, run.id);
    while (runStatus.status === 'in_progress' || runStatus.status === 'queued') {
      await new Promise(resolve => setTimeout(resolve, 500));
      runStatus = await this.openai.beta.threads.runs.retrieve(threadId, run.id);
    }
    
    if (runStatus.status === 'completed') {
      const messages = await this.openai.beta.threads.messages.list(threadId);
      const lastMessage = messages.data[0];
      
      if (lastMessage.content[0].type === 'text') {
        return JSON.parse(lastMessage.content[0].text.value);
      }
    }
    
    return { suggestions: [], clinicalFlags: [], historicalContext: "" };
  }
  
  // Complete processing after recording stops
  async processCompleteTranscription(
    threadId: string,
    fullTranscription: string,
    userRole: string,
    patientId: number,
    encounterId: number
  ) {
    await this.openai.beta.threads.messages.create(threadId, {
      role: "user",
      content: `COMPLETE TRANSCRIPTION: "${fullTranscription}"
USER ROLE: ${userRole}
ENCOUNTER_ID: ${encounterId}
MODE: COMPLETE_PROCESSING

Generate SOAP note, draft orders, CPT codes, and chart updates.`
    });
    
    const run = await this.openai.beta.threads.runs.create(threadId, {
      assistant_id: this.assistantId
    });
    
    // Wait for completion
    let runStatus = await this.openai.beta.threads.runs.retrieve(threadId, run.id);
    while (runStatus.status === 'in_progress' || runStatus.status === 'queued') {
      await new Promise(resolve => setTimeout(resolve, 1000));
      runStatus = await this.openai.beta.threads.runs.retrieve(threadId, run.id);
    }
    
    if (runStatus.status === 'completed') {
      const messages = await this.openai.beta.threads.messages.list(threadId);
      const lastMessage = messages.data[0];
      
      if (lastMessage.content[0].type === 'text') {
        return JSON.parse(lastMessage.content[0].text.value);
      }
    }
    
    throw new Error('Assistant processing failed');
  }
  
  private async getPatientHistory(patientId: number) {
    // Get comprehensive patient data from your new schema
    const [
      patient,
      familyHistory,
      socialHistory,
      allergies,
      recentVitals,
      currentMedications,
      activeDiagnoses,
      recentEncounters
    ] = await Promise.all([
      db.select().from(patients).where(eq(patients.id, patientId)).limit(1),
      db.select().from(familyHistory).where(eq(familyHistory.patientId, patientId)),
      db.select().from(socialHistory).where(eq(socialHistory.patientId, patientId)),
      db.select().from(allergies).where(eq(allergies.patientId, patientId)),
      db.select().from(vitals).where(eq(vitals.patientId, patientId))
        .orderBy(desc(vitals.measuredAt)).limit(10),
      db.select().from(medications).where(eq(medications.patientId, patientId))
        .where(eq(medications.status, 'active')),
      db.select().from(diagnoses).where(eq(diagnoses.patientId, patientId))
        .where(eq(diagnoses.status, 'active')),
      db.select().from(encounters).where(eq(encounters.patientId, patientId))
        .orderBy(desc(encounters.createdAt)).limit(5)
    ]);
    
    return {
      patient: patient[0],
      familyHistory,
      socialHistory,
      allergies,
      recentVitals,
      currentMedications,
      activeDiagnoses,
      recentEncounters
    };
  }
}
```